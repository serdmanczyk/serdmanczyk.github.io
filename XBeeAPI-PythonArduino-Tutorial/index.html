<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Steven Erdmanczyk Jr.">
<meta name="description" content="software engineer / adventurer">
<meta name="generator" content="Hugo 0.26" />
<title>XBee API Mode Tutorial Using Python and Arduino</title>
<link rel="shortcut icon" href="http://serdmanczyk.github.io/images/favicon.ico">
<link rel="stylesheet" href="http://serdmanczyk.github.io/css/style.css">
<link rel="stylesheet" href="http://serdmanczyk.github.io/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">



<link href="http://serdmanczyk.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Steven Erdmanczyk Jr." />


<meta property="og:title" content="XBee API Mode Tutorial Using Python and Arduino" />
<meta property="og:description" content="For the brave souls who really want to know." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://serdmanczyk.github.io/XBeeAPI-PythonArduino-Tutorial/" />



<meta property="article:published_time" content="2014-06-01T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2014-06-01T00:00:00&#43;00:00"/>













<meta itemprop="name" content="XBee API Mode Tutorial Using Python and Arduino">
<meta itemprop="description" content="For the brave souls who really want to know.">


<meta itemprop="dateModified" content="2014-06-01T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="5016">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="XBee API Mode Tutorial Using Python and Arduino"/>
<meta name="twitter:description" content="For the brave souls who really want to know."/>
<meta name="twitter:site" content="@https://twitter.com/serdmanczyk"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='http://serdmanczyk.github.io/'> <span class="arrow">‚Üê</span>Home</a>
	

	

	
		<a class="cta" href="http://serdmanczyk.github.io/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        
<article class="post">
    <header>
        <h1>XBee API Mode Tutorial Using Python and Arduino</h1>
        <h2 class="headline">
        June 1, 2014
        <br>
        
        </h2>
    </header>
    <section id="post-body">
        

<pre>
Disclaimer:  This is just a tutorial.
</pre>

<p>This is intended to educate with basic XBee
API mode setup, and how the XBee frame format works.</p>

<p>If you&rsquo;re looking for a library, I recommend for <a href="https://pypi.python.org/pypi/XBee">XBee</a> for
Python and checkout <a href="https://github.com/andrewrapp/xbee-arduino">xbee-arduino</a> for Arduino.</p>

<pre>
/Disclaimer
</pre>

<h2 id="introduction">Introduction</h2>

<p>This post is a tutorial, with example code, covering how to communicate using XBee 802.15.4 (Series 1) radios in API mode using Python and Arduino.  I decided to write these tutorials because I couldn&rsquo;t find a substantial amount of simple examples when I decided to use XBee&rsquo;s in API mode while working on my Masters thesis.  It&rsquo;s my hopes this tutorial can help other people working on applications similar to mine get off the ground and running faster.</p>

<p>Some knowledge of serial/UART communication mechanics, Python, and Arduino will be helpful for this tutorial but not absolutely required.  It&rsquo;s hopeful that this tutorial can aid in your learning if you&rsquo;re also picking these up as you go.  All example code is available at the <a href="https://github.com/serdmanczyk/XBee_802.15.4_APIModeTutorial" class="btn btn-success">GitHub Repository</a></p>

<p>This tutorial does assume you are familiar with Digi X-CTU and Arduino software.  You will be instructed what to do in X-CTU and Arduino (e.g. &ldquo;compile&rdquo;, &ldquo;change these settings&rdquo;), but will not be instructed how to do it (e.g. &ldquo;push the blue button&rdquo;, &ldquo;go to menu File-&gt;&rdquo;)</p>

<h2 id="requisite-hardware">Requisite Hardware</h2>

<ul>
<li>2 XBee 802.15.4 Series 1 radios</li>
<li>1 XBee 3.3v-5v adapter / break-out board</li>
<li>1 XBee USB adapter</li>
<li>1 Arduino board (This tutorial was written with an <a href="https://www.sparkfun.com/products/11021">Uno</a>)</li>
<li>1 Breadboard and jumper wires</li>
</ul>

<p>I recommend the <a href="http://amzn.com/B00B6SF2C6">Parallax XBee Wireless Pack</a>, but there are also several other options on <a href="https://www.sparkfun.com">SparkFun</a>, <a href="https://www.adafruit.com">Adafruit</a>, <a href="http://www.makershed.com/SearchResults.asp?Search=xbee">Maker Shed</a> and other hobby electronics stores.  Many of them are very similar to the pieces used in this post.</p>

<h2 id="requisite-software">Requisite Software</h2>

<ul>
<li><a href="http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/xctu">Digi X-CTU</a></li>
<li><a href="http://www.ftdichip.com/FTDrivers.htm">FTDI Drivers</a> (for USB to Serial communications)</li>
<li>Python <a href="https://www.python.org/download/releases/2.7.7/">2.7</a> or <a href="https://www.python.org/download/releases/3.3.5">3.3</a></li>
<li><a href="http://pyserial.sourceforge.net/">PySerial library</a></li>
<li><a href="http://arduino.cc/en/main/software">Arduino Software</a></li>
</ul>

<h2 id="why-xbee-802-15-4">Why XBee 802.15.4?</h2>

<p>XBee radios are handy in embedded applications because they enable wireless communications with relatively low power compared to Wi-Fi, bluetooth, or cellular technologies at the cost of slower speed.  XBee 802.15.4 (Series 1) provides simple OSI layer one and two functionality on the module.  Zigbee radios (XBee Series 2) provide an additional networking layer that can handle cool things like automatic mesh networking, however, Zigbee mesh networks are limited to a maximum of 10 nodes.  Zigbee radios can also operate in API mode, frame packaging is the same, and the frames used for Zigbee are very similar.  This tutorial covers XBee 80.15.4 because their frames are simpler for beginners and are all we need to cover the basics.</p>

<h2 id="why-xbee-api-mode-a-brief-review">Why XBee API mode? A Brief Review</h2>

<p>Using API mode to communicate has a few advantages compared to other XBee configuration options:</p>

<ul>
<li>No need for timely switching in/out of command mode to change configuration options</li>
<li>Message destination addresses can be specified on the fly</li>
<li>Received message frames come packaged with an RSSI (Received Signal Strength Indicator) byte</li>
<li>Feedback is provided on message transmission success when enabled</li>
</ul>

<p>In API mode, all incoming and outgoing messages are required to be packaged in frames.  The picture below summarizes a few of the basic frame types based on descriptions in the <a href="http://ftp1.digi.com/support/documentation/90000982_N.pdf">XBee 802.15.4 product manual</a>.</p>

<p><img src="/images/xbeetut/XBeeFramesOverview.png" alt="API Frames Summary" /></p>

<p>Each frame has a minimum of the the following:</p>

<ol>
<li>Start delimiter byte <code>0x7E</code> <em>&ldquo;there is a frame here&rdquo;</em></li>
<li>Most Significant Byte (MSB) <em>&ldquo;the start byte is at: &ldquo;</em></li>
<li>Least Significant Byte (LSB) <em>&ldquo;the end byte is at: &ldquo;</em></li>
<li>API identifier (cmdID) <em>&ldquo;the content looks like: &ldquo;</em></li>
<li>Frame data (including additional bytes specific to API message type)</li>
<li>Checksum byte <em>&ldquo;all contents compress to: &ldquo;</em></li>
</ol>

<p>The start delimiter simply denotes the beginning of a frame.  The MSB and LSB are used to indicate the length of the data in the frame.  The length of the frame is the number of bytes after the LSB, not including the checksum byte.  The MSB is always 0x00, so the LSB will be equivalent to the length.  Every frame will have an API identifier specifying what type of frame is being sent (this tutorial will cover the 16-bit address transmit and receive message types).  After the API identifier comes any additional bytes required by the specified frame type. After that is the actual frame data (in the case of a transmit and receive frame, the data to transmit/received).  The checksum byte is used to verify the integrity of the contents.  The checksum is calculate using the following process:</p>

<ol>
<li>Sum value of each byte after LSB</li>
<li>Preserve only the lower 8 bits (AND with <code>0xFF</code>)</li>
<li>Subtract the value from 255</li>
</ol>

<p>This enables simple verification of received frames because the lower 8 bits of the sum of all bytes after the LSB (including the checksum) will be equal to 255 or <code>0xFF</code>.</p>

<p>After formatting the previous parts, a final step is necessary if you&rsquo;re using API mode with escaped characters.  When escaping is enabled, any bytes (excluding the start delimiter) that contain reserved characters (<code>0x7E</code>, <code>0x7D</code>, <code>0x11</code>, and <code>0x13</code>) must be escaped so that the XBee will not interpret them as control characters.  This may seem like extra overhead, but escaped mode simplifies message reception so that you can count on any <code>0x7E</code> byte to only indicate a start delimiter (or an ignorable error).  This removes the need to program for more edge cases and simplifies code.</p>

<p>To escape a message, anywhere in the message (including the MSB, LSB, and checksum bytes) a reserved character appears, it should be replaced with an <code>0x7D</code> escape character followed by the original character XOR&rsquo;ed with <code>0x20</code>.  For example the bytes <code>00 11 23</code> after escaping would become <code>00 7D 31 23</code>.</p>

<p>So, in a nutshell, the process for formatting an API frame is:</p>

<ol>
<li>Calculate the full length of the message (minus start delimiter and checksum) and insert it as the LSB</li>
<li>Calculate and insert any bytes necessary for the API frame type</li>
<li>Calculate the checksum and place it at the end of the frame</li>
<li>Escape any reserved characters (including MSB, LSB, and checksum)</li>
</ol>

<p>That covers the basics of API frames / the boring part.  Now let&rsquo;s actually have some fun.</p>

<h2 id="part-one-initial-setup-and-communication-in-transparent-mode">Part One: Initial Setup and communication in Transparent Mode</h2>

<p>For all parts of this tutorial we&rsquo;ll have two XBee radios with different settings.  To make things easier we&rsquo;ll give them names.  For the rest of this tutorial &ldquo;Atreyu&rdquo; will refer to the XBee we&rsquo;re connecting to our computer and &ldquo;Falcor&rdquo; will refer to the XBee we&rsquo;re connecting to our Arduino.</p>

<p><img src="/images/xbeetut/Setup_Diagram.png" alt="Setup Diagram" /></p>

<p>We will start with both XBee&rsquo;s in transparent mode.  Atreyu will connect to the X-CTU console on our computer, and Falcor will be wired in passthrough mode so that it will reflect any messages sent to it directly back to Atreyu.</p>

<p>First we need to configure the proper parameters on the radios so they will talk to each other.  For both radios, use X-CTU to load the default parameters, and then configure/write the following settings:</p>

<pre><code>|                   Settings for Atreyu                |
| Name                            | Value              |
|:-----------------------------   | -----------------: |
| `MY` (16-bit source address)    | `0`                |
| `DH` (Destination Address High) | `0`                |
| `DL` (Destination Address Low)  | `1`                |
| `AP` (API Enable)               | `API Disabled [0]` |
</code></pre>

<pre><code>|                   Settings for Falcor                  |
| Name                            | Value                |
|:-----------------------------   | -------------------: |
| `MY`                            | `1`                  |
| `DH`                            | `0`                  |
| `DL`                            | `0`                  |
| `AP`                            | `API Disabled [0]`   |
</code></pre>

<p>Leave Atreyu connected to the computer with the X-CTU software.  Insert Falcor into your 3.3v-5v adapter/break-out board and connect the following pins from the break-out board:</p>

<ul>
<li>Connect the DIN pin to DOUT (passthrough)</li>
<li>Connect 5v and GND to a 5v power source</li>
<li>That&rsquo;s it!</li>
</ul>

<p>If you like, you can use the Arduino as an overly fanciful power supply.  We will be using it in Part Three, so this way we&rsquo;ll only need to modify one wire when we start communicating with the Arduino.  Connect the Arduino to power (computer USB, or DC-in from wall or a battery) and it will provide enough current through the 5v pin to power the XBee.</p>

<p><img src="/images/xbeetut/XBeePassThroughGraphic.png" alt="XBee Pass-Through Mode Connection" /></p>

<p>The illustration shows a SparkFun XBee explorer module because it is what is available in <a href="http://fritzing.org/home/">fritzing</a>.  The pin layout is identical to the module in the Parallax kit.
{: .notice}</p>

<p>If you&rsquo;ve set this up correctly, you should now be able to connect to Atreyu with the X-CTU console and start typing text and see it returned like below (Blue text is sent, Red is received).</p>

<p><img src="/images/xbeetut/HelloWorld_Passive.png" alt="Passive Hello World" /></p>

<p>Congratulations!  You&rsquo;ve successfully setup and communicated with the XBee&rsquo;s in transparent mode.  Now we&rsquo;re ready to switch Atreyu into API mode and start communicating using Python in part two.</p>

<h2 id="part-two-communicating-from-a-pc-w-api-mode-using-python">Part Two: Communicating from a PC w/API mode using Python</h2>

<p>Now that we have things setup and we&rsquo;ve verified they can communicate, we can switch our first XBee into API mode and begin sending messages with it via Python. Re-configure the following parameter on Atreyu to enable API mode.</p>

<pre><code>|        Settings for Atreyu        |
| Name    | Value                   |
| :-----  | -------------------:    |
| `AP`    | `API enabled w/PPP [2]` |
</code></pre>

<p>To test in X-CTU, you can create a packet with following Hex contents: <code>7E 00 10 01 00 FF FF 01 48 65 6C 6C 6F 20 57 6F 72 6C 64 E3</code> (You can copy and paste).  You should be able to send the example packet in the X-CTU console and get a response (still being reflected from Falcor) identical to the second image.</p>

<p><img src="/images/xbeetut/APIHelloWorldPacket.png" alt="API Hello World Packet" />
<img src="/images/xbeetut/APIHelloWorldResponse.png" alt="API Hello World Response" /></p>

<p>Congratulations!  You&rsquo;ve sent your first message with XBee API mode.  Now let&rsquo;s send a package using Python.</p>

<p>Go ahead and clone the GitHub repository for this tutorial if you haven&rsquo;t already.  Also, make sure you have installed PySerial as well.  Now navigate to the Python folder.  You will need to modify line 5 in main.py to match the port your XBee resides on.  Now if you navigate with a command prompt to this folder and run main.py your command prompt output should look like:</p>

<pre><code>$ C:/.../main.py
Tx: 7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3
Rx: 7e 00 10 81 00 01 24 00 48 65 6c 6c 6f 20 57 6f 72 6c 64 3d
Msg: Hello World
Tx: 7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 7d 5e
Rx: 7e 00 7d 31 81 00 01 24 00 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 d8
Msg: 7e 7d 11 13 5b 01 01 01 01 01 01 01
</code></pre>

<p>You did it!  What exactly did we do?  Let&rsquo;s start examining the code by looking at the body of main.py.</p>

<pre><code class="python">    xbee = XBee.XBee("COM3")  # Your serial port name here

    # A simple string message
    sent = xbee.SendStr("Hello World")
    sleep(0.25)
    Msg = xbee.Receive()
    if Msg:
        content = Msg[7:-1].decode('ascii')
        print("Msg: " + content)

    # A message that requires escaping
    xbee.Send(bytearray.fromhex("7e 7d 11 13 5b 01 01 01 01 01 01 01"))
    sleep(0.25)
    Msg = xbee.Receive()
    if Msg:
        content = Msg[7:-1]
        print("Msg: " + xbee.format(content))
</code></pre>

<p>As can be seen, we sent and received two messages.  The first messages contents were simply &ldquo;Hello World&rdquo; in ascii encoding.  The second message is a bit more obscure, it is formatted to demonstrate API mode character escaping which we&rsquo;ll get more into soon.  Now, let&rsquo;s get into the pieces that are the heart of this tutorial.  Lets start with the XBee <code>__init__()</code> method.</p>

<pre><code class="python">class XBee():
    ...
    def __init__(self, serialport, baudrate=9600):
        self.serial = serial.Serial(port=serialport, baudrate=baudrate)
</code></pre>

<p>All the class constructor does is initialize the serial port.  You can read more on PySerial options in the <a href="http://pyserial.sourceforge.net/pyserial_api.html">PySerial API documentation</a>.</p>

<p>Now lets look at the interesting stuff, starting with the SendStr() method.</p>

<pre><code class="python">    def SendStr(self, msg, addr=0xFFFF, options=0x01, frameid=0x00):
        return self.Send(msg.encode('utf-8'), addr, options, frameid)
</code></pre>

<p>The <code>SendStr()</code> simply decodes the message into a bytes object using UTF-8 encoding and passes it to the <code>Send()</code> method.  If you&rsquo;re only using characters from the ascii set they will only require one byte per character.</p>

<p>What is a bytes object?  A bytes object is basically an array of integers with values between 0-255, so literally: bytes. You can read up more on bytes and bytearrays in the <a href="https://docs.python.org/3.1/library/stdtypes.html#bytes-methods">Python documentation</a> and <a href="http://dabeaz.blogspot.com/2010/01/few-useful-bytearray-tricks.html">this helpful blog post</a>.  Bytes and bytearray objects are the required inputs for the PySerial library.  A bytearray is basically the same as a bytes object, except mutable.  Now lets look at the <code>Send()</code> method.</p>

<pre><code>    def Send(self, msg, addr=0xFFFF, options=0x01, frameid=0x00):
        if not msg:
            return 0

        hexs = '7E 00 {:02X} 01 {:02X} {:02X} {:02X} {:02X}'.format(
            len(msg) + 5,           # LSB (length)
            frameid,
            (addr &amp; 0xFF00) &gt;&gt; 8,   # Destination address high byte
            addr &amp; 0xFF,            # Destination address low byte
            options
        )

        frame = bytearray.fromhex(hexs)
        #  Append message content
        frame.extend(msg)

        # Calculate checksum byte
        frame.append(0xFF - (sum(frame[3:]) &amp; 0xFF))

        # Escape any bytes containing reserved characters
        frame = self.Escape(frame)

        print(&quot;Tx: &quot; + self.format(frame))
        return self.serial.write(frame)
</code></pre>

<p><code>Send()</code> accepts &lsquo;msg&rsquo; as its first parameter, which is expected to be a bytes or bytearray object.  Optionally you can specify an address, options, or a frameid but the defaults are to broadcast, disable acknowledgments, and have no frameid.</p>

<p>The first thing the <code>Send()</code> method does is initialize a transmit request frame in a bytearray object.  It first formats a string that contains the desired hex characters using string formatting operations.  This isn&rsquo;t the most efficient way, but it makes things more readable.  Then the bytearray <code>fromhex()</code> method will decode the string into a bytearray object e.g. <code>bytearray.fromhex()</code> with the strings <code>&quot;7E 00&quot;</code>, <code>&quot;7E00&quot;</code>, <code>&quot; 7e00&quot;</code>, and <code>&quot;7e00 &quot;</code> will all create a bytearray object with bytes <code>[0x7E, 0x00]</code>.  We use this method to input our LSB, frameid, address, and options bytes (MSB is always zero).  Our LSB is equivelant to the length of our frame between the LSB and checksum or rather the length of the message contents plus 5 bytes: the API type, frameid, address, and options bytes required for a transmission request frame.</p>

<p>Next the function extends the frame to contain our message.  Then the checksum is calculate and appended to the end.  Now that our frame is formatted, we escape any reserved characters after the start delimiter using the <code>Escape()</code> method.</p>

<pre><code>    def Escape(self, msg):
        escaped = bytearray()
        reserved = bytearray(b&quot;\x7E\x7D\x11\x13&quot;)

        escaped.append(msg[0])
        for m in msg[1:]:
            if m in reserved:
                escaped.append(0x7D)
                escaped.append(m ^ 0x20)
            else:
                escaped.append(m)

        return escaped
</code></pre>

<p>After escaping, the message is ready to send!  The <code>Send()</code> function prints the formatted frame for debug using the <code>format()</code> function, and then passes it to the serial port with the PySerial <code>write()</code> method.  The <code>format()</code> function is just a simple function to convert a byte object into a more readable string for debug output.</p>

<pre><code>    def format(self, msg):
        return &quot; &quot;.join(&quot;{:02x}&quot;.format(b) for b in msg)
</code></pre>

<p>Here&rsquo;s a breakdown of the contents of the formatted frames for the two messages in main.py:</p>

<pre><code>Msg: Hello World ------------------------------------------------------------------------------
                                                                Checksum |
                                        -  &quot;hello world&quot; in Ascii -      |
                             Options |                                   |
                      Address LSB |  |                                   |
                   Address MSB |  |  |                                   |
                   Frame ID |  |  |  |                                   |
              Tx Request |  |  |  |  |                                   |
                  LSB |  |  |  |  |  |                                   |
               MSB |  |  |  |  |  |  |                                   |
start delimiter |  |  |  |  |  |  |  |                                   |
                |  |  |  |  |  |  |  |                                   |
                7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3


Msg: 7e 7d 11 13 5b 01 01 01 01 01 01 01 ------------------------------------------------------
                                                                           Escaped Checksum |
                                Options |                                                   |
                         Address LSB |  |                                                   |
                      Address MSB |  |  |                                                   |
                      Frame ID |  |  |  |                                                   |
                 Tx Request |  |  |  |  |                                                   |
          LSB Escaped |     |  |  |  |  |                                                   |
               MSB |  |     |  |  |  |  |                                                   |
start delimiter |  |  |     |  |  |  |  |                                                   |
                7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 7d 5e
</code></pre>

<p>So you can see, the second message is specially designed so the LSB and checksum bytes in the formatted frame require escaping, just to demonstrate that necessity (and that it works).</p>

<p>That&rsquo;s it for sending a message.  The next step is to receive the message.  This gets a bit more complicated.  When you receive through serial, it&rsquo;s not guaranteed that the entire message will come through at once.  You also may get the beginning of another message.  It&rsquo;s important to receive as much as possible in a call, parse out any messages, and hold onto any remaining bytes until the next time your program attempts to receive.  This is done in the example code <code>Receive()</code> method:</p>

<pre><code>    def Receive(self):
        remaining = self.serial.inWaiting()
        while remaining:
            chunk = self.serial.read(remaining)
            remaining -= len(chunk)
            self.RxBuff.extend(chunk)

        msgs = self.RxBuff.split(bytes(b'\x7E'))
        for msg in msgs[:-1]:
            self.Validate(msg)

        self.RxBuff = (bytearray() if self.Validate(msgs[-1]) else msgs[-1])

        if self.RxMessages:
            return self.RxMessages.popleft()
        else:
            return None
</code></pre>

<p>The code first receives any data available on the serial port.  Thanks to python, we can easily &lsquo;split&rsquo; the buffer around the <code>0x7E</code> start delimiter into a list of bytearrays then iterate through them.  Each call to <code>Validate()</code> will append the message to the <code>RxMessages</code> if the message validates.  If the last message doesn&rsquo;t validate, it may be the beginning of a new message, so the method holds onto it until the next call.</p>

<p>With this code, if you send data and call <code>Receive()</code> immediately, the response message will not be ready in the serial buffer yet.  Python code runs much faster than the 9600 baud rate at which the serial port is operating.  Because of this it&rsquo;s necessary to pause at least the minimum amount of time it takes the message to transmit, the source to process/respond, and the radio to receive/send the message back to our program.  This is why main.py sleeps for <sup>1</sup>&frasl;<sub>4</sub> second after sending.  In production code it may be more reasonable to use callbacks or threading, but that&rsquo;s beyond the scope of this tutorial; we&rsquo;ll keeping it simple.  Still, there is an alternate version of XBee.py with threads and thread-safe Queues for message reception in the repository if you&rsquo;re interested.
{: .notice}</p>

<p>For each start delimiter found in the receive buffer, the <code>validate()</code> method is called.</p>

<pre><code>    def Validate(self, msg):
        # 9 bytes is Minimum length to be a valid Rx frame
        #  LSB, MSB, Type, Source Address(2), RSSI,
        #  Options, 1 byte data, checksum
        if (len(msg) - msg.count(bytes(b'0x7D'))) &lt; 9:
            return False

        # All bytes in message must be unescaped before validating content
        frame = self.Unescape(msg)

        LSB = frame[1]
        # Frame (minus checksum) must contain at least length equal to LSB
        if LSB &gt; (len(frame[2:]) - 1):
            return False

        # Validate checksum
        if (sum(frame[2:3+LSB]) &amp; 0xFF) != 0xFF:
            return False

        print(&quot;Rx: &quot; + self.format(bytearray(b'\x7E') + msg))
        self.RxMessages.append(frame)
        return True
</code></pre>

<p>The first thing the <code>Validate()</code> method does is double check the message array (minus any escapes) is at least the size required for a message.  The next thing it does is undo any escape characters with the <code>Unescape()</code> method.</p>

<pre><code>    def Unescape(self, msg):
        if msg[-1] == 0x7D:
            # Last byte indicates an escape, can't unescape that
            return None

        out = bytearray()
        skip = False
        for i in range(len(msg)):
            if skip:
                skip = False
                continue

            if msg[i] == 0x7D:
                out.append(msg[i+1] ^ 0x20)
                skip = True
            else:
                out.append(msg[i])

        return out
</code></pre>

<p>We need to do this before the next steps to read the LSB and checksum bytes.  Then the <code>Validate()</code> method double checks the current frame length is at least the size indicated by the LSB.  If it is, the last step in validation is to verify the checksum by summing all characters from the LSB up to the checksum and making sure the lower byte is equal to <code>0xFF</code>.  If all this checks out, we have a valid message!  The message is now printed for debug output and placed in the <code>RxMessages</code> list member variable.</p>

<p>That concludes all the example pieces to do basic message sending and receiving in API mode using Python.  Next, we&rsquo;ll switch worlds into C++ code to handle message reception on an Arduino.</p>

<h2 id="part-three-communicating-from-an-arduino-w-api-mode">Part Three: Communicating from an Arduino w/API mode</h2>

<p>Now we&rsquo;ll need to re-connect Falcor to our computer briefly to reset the following parameters in X-CTU:</p>

<pre><code>|        Settings for Falcor        |
| Name    | Value                   |
| :-----  | -------------------:    |
| `AP`    | `API enabled w/PPP [2]` |
</code></pre>

<p>Now return Falcor to the 3.3v-5v breakout board but don&rsquo;t wire it yet.</p>

<p>Before wiring the Arduino to the XBee, we&rsquo;ll need to load our software onto the board.  The Arduino software should recognize the Arduino.ini file, once loaded simply compile and load the program onto your board.  Once it&rsquo;s programmed, disconnect the Arduino and wire the XBee to it like so:</p>

<ul>
<li>Connect DOUT (3 from top left) to port 12 on Arduino</li>
<li>Connect DIN (4 from top left) to port 13 on Arduino</li>
<li>Leave 5v and GND connect as before (if you used Arudino as power source, otherwise, connect them to Arduino 5v,GND)</li>
</ul>

<p><img src="/images/xbeetut/XBeeArduinoGraphic.png" alt="Passive Hello World" /></p>

<p>We&rsquo;re using pins 12, 13 as our Rx, Tx pins respectively using the SoftwareSerial library.  This frees up the default Tx,Rx pins to send debug data to our computer if you like.  This also allows you to communicate while plugged into your computer port, otherwise the Arduino serial would be occupied by the connection to your computer.  In realistic applications you would want to use a hardware serial port with its own UART.</p>

<p>Assuming everything is plugged in, you can go back to your console from Part Two and run main.py again.  You should get an output that looks like this:</p>

<pre><code>$ C:/.../main.py
Tx: 7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3
Rx: 7e 00 1a 81 00 01 18 00 79 6f 75 20 73 65 6e 74 3a 20 48 65 6c 6c 6f 20 57 6f 72 6c 64 b8
Msg: you sent: Hello World
Tx: 7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 FIFO 01 7d 5e
Rx: 7e 00 1b 81 00 01 1a 00 79 6f 75 20 73 65 6e 74 3a 20 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 51
Msg: 79 6f 75 20 73 65 6e 74 3a 20 7e 7d 11 13 5b 01 01 01 01 01 01 01
</code></pre>

<p>You&rsquo;ll notice it&rsquo;s the same content as earlier, except now our returned messages have &ldquo;you sent: &ldquo; appended to the front.  The Arduino is now receiving, editing, and then returning our messages.</p>

<p>So there it is, you&rsquo;ve now sent and received data in API mode with Python and Arduino.  New doors will open and bells will ring as you celebrate this wondrous day.  I&rsquo;ll let you call your parents and tell them, but when you&rsquo;re done let&rsquo;s review the code.</p>

<p>As before, we&rsquo;ll begin with our main code in Arduino.ino.  First the setup:</p>

<pre><code>XBee xbee;
Queue RxQ;
SoftwareSerial sserial(12,13);

void setup(void)
{
    sserial.begin(9600);
}
</code></pre>

<p>We instantiate an instance of the XBee, Queue, and SoftwareSerial classes.  We&rsquo;ll go more into detail on the XBee class soon.  The Queue is a C++ implementation of a standard FIFO queue for the unsigned char data type, with a couple home-brewed helper methods to aid in this application.  If that sounds unfamiliar, google &ldquo;FIFO queue&rdquo; and read up on them, it&rsquo;s a handy data structure.  One of the most basic.  We&rsquo;ll use the queue as our receive buffer.  The only code in our <code>setup()</code> method is to start off our serial connection at 9600 baud.</p>

<pre><code>void loop(void)
{
    delay(5);
    int queueLen = 0;
    int delPos = 0;

    while (sserial.available() &gt; 0){
        unsigned char in = (unsigned char)sserial.read();
        if (!RxQ.Enqueue(in)){
            break;
        }
    }

    queueLen = RxQ.Size();
    for (int i=0;i&lt;queueLen;i++){
        if (RxQ.Peek(i) == 0x7E){
            unsigned char checkBuff[Q_SIZE];
            unsigned char msgBuff[Q_SIZE];
            int checkLen = 0;
            int msgLen = 0;

            checkLen = RxQ.Copy(checkBuff, i);
            msgLen = xbee.Receive(checkBuff, checkLen, msgBuff);
            if (msgLen &gt; 0){
                unsigned char outMsg[Q_SIZE];
                unsigned char outFrame[Q_SIZE];
                int frameLen = 0;
                int addr = ((int)msgBuff[4] &lt;&lt; 8) + (int)msgBuff[5];

                // 10 is length of &quot;you sent: &quot;
                memcpy(outMsg, &quot;you sent: &quot;, 10);
                // len - (9 bytes of frame not in message content)
                memcpy(&amp;outMsg[10], &amp;msgBuff[8], msgLen-9);

                // 10 + (-9) = 1 more byte in new content than in previous message
                frameLen = xbee.Send(outMsg, msgLen+1, outFrame, addr);
                sserial.write(outFrame, frameLen);
                i += msgLen;
                delPos = i;
            }else{
                if (i&gt;0){
                    delPos = i-1;
                }
            }
        }
    }

    RxQ.Clear(delPos);
}
</code></pre>

<p>That&rsquo;s a lot to take in real quick, but don&rsquo;t be too intimidated.  This is what is going on in the <code>loop()</code> method:</p>

<ol>
<li>A small 5ms delay, to give the serial time to do work.</li>
<li>Check the serial buffer for content.  If any is available, read it into the queue.</li>
<li>Parse through the queue for a start delimiter.</li>
<li>If a delimiter is found, check if the content after the delimiter is a proper message using <code>XBee.Receive()</code>.</li>
<li>If the content is valid, create a new message to send.</li>
<li>New message is &ldquo;you sent: &ldquo; + content of received message.  Message is created using <code>XBee.Send()</code> using address parsed from incoming frame, then sent using the <code>write()</code> call to SoftwareSerial.</li>
<li>After parsing is done the delPos variable stores off the last location of possible good/unused data in the queue, it is used to clear any unneeded contents.  We may not have received the full portion of a message yet, so we&rsquo;ll hold on to any we may still want.</li>
</ol>

<p>The code makes liberal use of buffers to keep code &lsquo;simpler&rsquo; as lengths vary between the data in the queue, the read message and output messages.  Algorithmically there&rsquo;s definitely more efficient ways to do this, but that would be hell to read for a tutorial.  Something more eye friendly could possibly be written with other Arduino libraries such as String, but as a guy used to using C in embedded applications I stuck to what I know.  Maybe an optimization for a future version :).</p>

<p>Now, let&rsquo;s once again get to the guts of our code.  All of the main parts should look very familiar.  It&rsquo;s basically carbon copies of the Python methods, except with C-friendly data structures.  I won&rsquo;t add too much wordiness to the tutorial by re-explaining how things work, so I&rsquo;ll just put the code here to peruse.  But just for a quick re-hash:</p>

<ul>
<li><code>Receive()</code> validates content to ensure it is a proper message</li>
<li><code>unescape()</code> parses out escaped characters to their original content</li>
<li><code>Send()</code> Takes input content and places it into a Tx request frame (the calling method is expected to send it)</li>
<li><code>escape()</code> takes an input buffer and escapes any reserved characters.</li>
</ul>

<p>All XBee methods count on the calling class to provide the input and output buffers.  For all buffer sizes we&rsquo;re using the Q_SIZE defined in our Queue class, since that&rsquo;s the max data we&rsquo;ll encounter.  The size is set to 220, a comfortable size larger than the max XBee message size of 100.  This, of course, assumes you may only receive max one 100 byte frame at a time.  This size is safe for simple applications such as this.</p>

<pre><code>int XBee::Receive(unsigned char *inBuff, int len, unsigned char *outBuff){
    int unescapeLen = 0;
    unsigned char checksum = 0;
    unsigned char LSB = 0;

    if (inBuff[0] != 0x7E)
        return 0;

    if (len &lt; 10)
        return 0;

    unescapeLen = unescape(inBuff, len, outBuff);

    // Check we have at least the amount of bytes indicated by LSB
    LSB = outBuff[2];
    if (LSB &gt; (unescapeLen - 4))
        return 0;

    // Calculate our checksum
    // (char will overflow, no need to AND for lower bytes)
    for (int i=3; i&lt;LSB+4; i++){
        checksum += outBuff[i];
    }

    if (checksum != 0xFF)
        return 0;

    return LSB+4;
}
</code></pre>

<pre><code>int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;
    bool skip = false;
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i&lt;inLen; i++) {
        if (skip){
            skip = false;
            continue;
        }

        if (input[i] == 0x7D){
            curr = input[i+1] ^ 0x20;
            skip = true;
        }else{
            curr = input[i];
        }

        output[pos] = curr;
        pos++;
    }

    return pos;
}
</code></pre>

<pre><code>int XBee::Send(unsigned char *msg, int len, unsigned char *outBuff, int addr){
    unsigned char buf[100];
    int escapedLen = 0;
    unsigned char checksum = 0;

    buf[0] = 0x7E;
    buf[1] = 0x00;
    // LSB = content + 5 (content length + API type + frameid + addr(2) + options)
    buf[2] = (unsigned char)(len + 5);
    buf[3] = 0x01;  // transmit request
    buf[4] = 0x00;  // Frame ID
    buf[5] = (unsigned char)((addr &amp; 0xFF00) &gt;&gt; 8);
    buf[6] = (unsigned char)(addr &amp; 0xFF);
    buf[7] = 0x01;  // Disable acknowledge
    memcpy(&amp;buf[8], msg, len);

    for (int i=3;i&lt;len+8;i++){
        checksum += buf[i];
    }

    // Total length = LSB + 9 (LSB value + MSB + LSB + start delimiter + checksum)
    buf[len+8] = 0xFF - checksum;
    escapedLen = escape(buf, len+9, outBuff);

    return escapedLen;
}
</code></pre>

<pre><code>int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;

    output[0] = input[0];
    for (int i=1; i&lt;inLen; i++){
        switch(input[i]){
            case 0x7D:
            case 0x7E:
            case 0x11:
            case 0x13:
                output[pos++] = 0x7D;
                output[pos++] = input[i] ^ 0x20;
                break;
            default:
                output[pos++] = input[i];
                break;
      }
   }

   return pos;
}
</code></pre>

<p>That sums up all the main parts of the XBee example code.</p>

<h2 id="review">Review</h2>

<p>That covers a basic example of programming for XBee 802.15.4 radios configured in API mode.  I found API mode very helpful when programming for my Masters thesis, which you should check out the <a href="https://github.com/serdmanczyk/masters-thesis">source code for</a> if you would like to see an example of receiving, parsing, and sending many different API frame types in an actual application.  Hopefully this tutorial and example code enable you to get off the ground running with your application, or better understand some feature of Python, Arduino, XBee, serial communications, etc.  If you&rsquo;ve encounter any trouble running the examples, or have any questions / comments / concerns please post them in the comments so others with similar problems can see too :).</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    
    <img class="avatar" src="http://serdmanczyk.github.io/images/avatar.png">
    <div>
        <span class="dark">Steven Erdmanczyk Jr.</span>
        <span>Software Developer</span>
    </div>
    
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fserdmanczyk.github.io%2fXBeeAPI-PythonArduino-Tutorial%2f - XBee%20API%20Mode%20Tutorial%20Using%20Python%20and%20Arduino "><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "serdmanczyk" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/post/2017-08-25-Server/">One server to host them all, subdomains to find them, docker-compose to bring them all, and a reverse proxy to bind them<aside class="dates">Aug 25 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/2017-08-24-Bifrost/">Bifr√∂st - a queryable in-process worker queue (golang)<aside class="dates">Aug 24 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/2016-10-14-GoFullstackApp/">A fullstack Go &#43; ReactJS App deployed with Docker<aside class="dates">Oct 23 2016</aside></a>
        </li>
    
        <li>
            <a href="/post/2016-03-12-PythonObserverMetaclass/">Python Observer Metaclass<aside class="dates">Mar 12 2016</aside></a>
        </li>
    
        <li>
            <a href="/post/2015-06-11-Python_XBee_Sounds_Library/">Notes and Chords using Python<aside class="dates">Jun 11 2015</aside></a>
        </li>
    
        <li>
            <a href="/post/2015-02-12-moving-to-seattle-hows-the-weather/">Moving to Seattle, How&#39;s the Weather? (graphs!)<aside class="dates">Feb 25 2015</aside></a>
        </li>
    
        <li>
            <a href="ClassAtttendanceApp/">Online Class Attendance App using Flask/MongoDB<aside class="dates">Jun 18 2014</aside></a>
        </li>
    
        <li>
            <a href="BlogStarts/">Developer Blog Begins<aside class="dates">May 29 2014</aside></a>
        </li>
    
        <li>
            <a href="MSEEThesis/">Master&#39;s Thesis<aside class="dates">May 28 2014</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="mailto:serdmanczyk@gmail.com">
        <i class="fa fa-envelope"></i>
    </a>
    
    <a class="symbol" href="https://github.com/serdmanczyk">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://www.linkedin.com/in/sjerdmanczykjr/">
        <i class="fa fa-linkedin"></i>
    </a>
    
    <a class="symbol" href="https://stackoverflow.com/users/2406040/serdmanczyk">
        <i class="fa fa-stack-overflow"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/serdmanczyk">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        ¬© Copyright 2017 Steven Erdmanczyk Jr.
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://serdmanczyk.github.io/js/main.js"></script>
<script src="http://serdmanczyk.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51048910-1', 'auto');
ga('send', 'pageview');
</script>


</body>
</html>
