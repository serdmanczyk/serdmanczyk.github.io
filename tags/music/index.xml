<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Music on Erdmanczyk.io</title>
    <link>http://serdmanczyk.github.io/tags/music/</link>
    <description>Recent content in Music on Erdmanczyk.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Jun 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://serdmanczyk.github.io/tags/music/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Notes and Chords using Python</title>
      <link>http://serdmanczyk.github.io/Python_XBee_Sounds_Library/</link>
      <pubDate>Thu, 11 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://serdmanczyk.github.io/Python_XBee_Sounds_Library/</guid>
      <description>&lt;p&gt;Life events: my wife and I will be closing on a house in a couple days.  Yay!&lt;/p&gt;

&lt;p&gt;Things have moved quick since moving here to Seattle and I&amp;rsquo;ve realized I haven&amp;rsquo;t been as good about posting on this blog.  Just to get content on here, I figured I would share a recent small project I&amp;rsquo;ve been working on.&lt;/p&gt;

&lt;p&gt;In what time I can spare I&amp;rsquo;ve working on an education course for a hackerspace / STEAM education group here in Seattle.  I wanted to model the course after my Masters Thesis work, so one idea was getting youth engaged with using wireless communications.  One tool I thought would aid in engaging youth would be if they could easily program Arduino/XBee boards to play music, even chords on a remote machine.  This also aids given the interrelation of sound and radio communications having wave properties.  The basic idea is that the kids would program Arduino (or similar) microcontrollers to send messages via XBee that are translated on a central computer into music notes.&lt;/p&gt;

&lt;p&gt;I found plenty of existing examples of generating sine waves using numpy, and turning that data into notes with pyaudio.&lt;/p&gt;

&lt;p&gt;These examples didn&amp;rsquo;t suite my situation because they all used blocking calls to play audio.  You issue the command to play a note and can&amp;rsquo;t issue another until the note was finished.  I wanted to stream audio, and update the stream if a new note was entered.  This required a bit more reading into the pyaudio API.  Since this was a bit of effort for me, I figured I would share for others.&lt;/p&gt;

&lt;p&gt;This is just a starting framework that turns a computer keyboard into a music generating keyboard.  Currently it just assigns notes at random, or sequentially (see commented line 29).  Once a key is pressed, it continues to play the same note.  If all notes are assigned, random notes are given to new keys.&lt;/p&gt;


#!/usr/bin/python
# coding=utf-8

import numpy
import random
import math
import copy
import pyaudio
from Tkinter import *

class NoteGen(object):
    def __init__(self, notes=range(30,70)):
        self.choices = list(map(self._note, notes))
        self.possibilities = copy.copy(self.choices)
        self.mapping = {}

    def __call__(self, key, duration=float(&#34;inf&#34;), amplitude=1):
        note = self._get(key, duration, amplitude)
        if not note:
            note = self._map(key, duration, amplitude)
        return note

    def _map(self, key, duration, amplitude):
        if not self.possibilities:
            self.mapping[key] = random.choice(self.choices)
            return Note(self.mapping[key], duration, amplitude)

        n = self.possibilities[0]
        # n = random.choice(self.possibilities)
        self.possibilities.remove(n)
        self.mapping[key] = n
        return Note(n, duration, amplitude)

    def _get(self, key, duration, amplitude):
        if key in self.mapping:
            return Note(self.mapping[key], duration, amplitude)

    def _note(self, n):
        return math.pow(2, (float(n)-49) / 12) * 440


class Note(object):
    names = [
        &#34;A&#34;,
        &#34;A#/Bf&#34;,
        &#34;B&#34;,
        &#34;C&#34;,
        &#34;C#/Df&#34;,
        &#34;D&#34;,
        &#34;D#/Ef&#34;,
        &#34;E&#34;,
        &#34;F&#34;,
        &#34;F#/Gf&#34;,
        &#34;G&#34;,
        &#34;G#/Af&#34;
    ]

    def __init__(self, frequency=440, duration=float(&#34;inf&#34;), amplitude=1, rate=44100):
        self.frequency = frequency
        self.total_frames = duration * rate
        self.frame_offset = 0
        self.rate = rate
        self.amplitude = amplitude

    def __call__(self, frames):
        if self.done:
            return numpy.zeros(frames, float)

        factor = float(self.frequency) * ((math.pi * 2) / self.rate)
        
        length = (frames if frames &lt; self.remaining else self.remaining)
        sin = numpy.sin((numpy.arange(length) + self.frame_offset) * factor) * self.amplitude
        if frames &gt; self.remaining:
            sin = numpy.concatenate([sin, numpy.zeros(frames - self.remaining, float)])

        self.frame_offset += frames
        return sin

    def __lt__(self, other):
        return self.frequency &lt; other.frequency

    def __eq__(self, other):
        return self.frequency == other.frequency
    
    @property
    def remaining(self):
        return self.total_frames - self.frame_offset
    
    @property
    def done(self):
        return self.frame_offset &gt;= self.total_frames

    @property
    def name(self):
        keynum = int((12 * math.log((self.frequency / 440), 2))  +  48) % 12
        return self.names[keynum]

class Chord(object):
    def __init__(self):
        self.notes = []

    def __call__(self, duration):
        if not len(self.notes):
            return numpy.zeros(duration, float)

        gen = lambda note:note(duration)
        output = sum(map(gen, self.notes))
        self.clean()
        return output

    def add_note(self, note):
        if not isinstance(note, Note):
            raise ValueError(&#34;Must be of type Note&#34;)

        self.notes.append(note)

    def remove_note(self, note):
        if not isinstance(note, Note):
            return

        if note in self.notes:
            self.notes.remove(note)

    def clean(self):
        for note in self.notes:
            if note.done:
                self.notes.remove(note)


if __name__ == &#34;__main__&#34;:
    p = pyaudio.PyAudio()
    chord = Chord()
    gen = NoteGen()

    def callback(in_data, frame_count, time_info, status):
        wave = chord(frame_count)
        data = wave.astype(numpy.float32).tostring()
        return (data, pyaudio.paContinue)

    stream = p.open(
        format=pyaudio.paFloat32,
        channels=1,
        rate=44100,
        output=True,
        stream_callback=callback
    )

    stream.start_stream()

    def keydown(event):
        k = gen(event.char, 1)
        chord.add_note(k)
        print [(n.name, n.frequency) for n in chord.notes]

    def keyup(event):
        pass
        # k = gen(event.char)
        # chord.remove_note(k)
        # print [n.name for n in chord.notes]


    root = Tk()
    frame = Frame(root, width=100, height=100)
    frame.bind_all(&#34;&lt;KeyPress&gt;&#34;, keydown)
    frame.bind_all(&#34;&lt;KeyRelease&gt;&#34;, keyup)
    frame.pack()

    root.mainloop()

    stream.stop_stream()
    stream.close()
    p.terminate()


&lt;p&gt;This is also available on Github as a &lt;a href=&#34;https://gist.github.com/serdmanczyk/5a9389d80db94440cf15&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>