<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Steven Erdmanczyk Jr. </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://serdmanczyk.github.io/tags/software/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>A fullstack Go &#43; ReactJS App deployed with Docker</title>
      <link>http://serdmanczyk.github.io/post/2016-10-14-GoFullstackApp/</link>
      <pubDate>Sun, 23 Oct 2016 20:00:01 PDT</pubDate>
      
      <guid>http://serdmanczyk.github.io/post/2016-10-14-GoFullstackApp/</guid>
      <description>

&lt;h2 id=&#34;what&#34;&gt;What?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve written a fullstack app: Go backend, ReactJS web frontend, deployed using Docker-Compose.&lt;/p&gt;

&lt;p&gt;I call it Freyr, obligatory screenshots:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/serdmanczyk/Freyr/raw/v1.0/repo_files/Screenshot%202016-05-09%2023.17.39.png&#34; alt=&#34;Screenshot 2016-05-09 23.17.39.png&#34; /&gt;
&lt;img src=&#34;https://github.com/serdmanczyk/Freyr/raw/v1.0/repo_files/Screenshot%202016-05-09%2023.17.48.png&#34; alt=&#34;Screenshot 2016-05-09 23.17.48.png&#34; /&gt;
&lt;img src=&#34;https://github.com/serdmanczyk/Freyr/raw/v1.0/repo_files/Screenshot%202016-05-09%2023.18.04.png&#34; alt=&#34;Screenshot 2016-05-09 23.18.04.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can read more about the app itself on its &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/tree/v1.0&#34;&gt;github page&lt;/a&gt;.  You can even view the app actually running at &lt;a href=&#34;https://freyr.erdmanczyk.com/latest&#34;&gt;frey.erdmanczyk.com&lt;/a&gt;.  In this post I&amp;rsquo;ll share an overview of the app&amp;rsquo;s design.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s yet another &amp;lsquo;arduino&amp;rsquo; (in this case a &lt;a href=&#34;https://docs.particle.io/datasheets/core-datasheet/&#34;&gt;Particle Core&lt;/a&gt;) plant sensor project: meausuring temperature, humidity, light, etc. with sensors and an MCU and then sending it to the cloud.  Unlike many other projects, however, the cloud server is custom built.&lt;/p&gt;

&lt;h2 id=&#34;why&#34;&gt;Why?&lt;/h2&gt;

&lt;p&gt;I cover the &amp;lsquo;why&amp;rsquo; of the app on the github page, but why this post?&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re looking to write an app in Go, there is hardly a lack of resources for learning.  Be it tutorials, examples, existing libraries, etc. Go has a rich community.&lt;/p&gt;

&lt;p&gt;My goal with this post isn&amp;rsquo;t to make a mega-tutorial covering all the how-to&amp;rsquo;s of what I did in this project, but to provide a simple example of pulling those components together into a Thing™.&lt;/p&gt;

&lt;p&gt;Rather than an exhaustive overview of how to build this from the ground up, this will instead be a high-level overview of the app, its components, and their purposes.  I&amp;rsquo;ll make some assumptions that the reader understands how the underlying technology works, but if you see something cool and want to know more feel free to comment/e-mail ☺.&lt;/p&gt;

&lt;h2 id=&#34;how-does-this-work&#34;&gt;How does this work?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/deploygoapp/layout.png&#34; alt=&#34;App layout&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deployed via docker-compose&lt;/li&gt;
&lt;li&gt;Nginx gateway&lt;/li&gt;
&lt;li&gt;ReactJS frontend&lt;/li&gt;
&lt;li&gt;Go backend w/ Postgres database&lt;/li&gt;
&lt;li&gt;Google oauth authentication, &lt;a href=&#34;https://jwt.io/&#34;&gt;JWT&lt;/a&gt; managed sessions, HMAC signed API access&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;Docker-compose was great because I could script my app environments.  This made spinning up and tearing down the apps on the fly super easy.&lt;/p&gt;

&lt;p&gt;Another benefit was the provider I used for this project, &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;DigitalOcean&lt;/a&gt;, has a &lt;a href=&#34;https://docs.docker.com/machine/drivers/digital-ocean/&#34;&gt;docker-machine driver&lt;/a&gt;.  I created my VM with docker-machine, then could use the same docker client commands to deploy my app in production as I do to test on my local machine.&lt;/p&gt;

&lt;p&gt;The repository has four Docker Compose files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/docker-compose.yml&#34;&gt;docker-compose.yml&lt;/a&gt;: Production deployment, pulls all files into the images&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/docker-compose.debug.yml&#34;&gt;docker-compose.debug.yml&lt;/a&gt;: Rather than copying in files, mounts directories into the container to speed launching docker as well as allow live editing of things such as UI files.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/docker-compose.integration.yml&#34;&gt;docker-compose.integration.yml&lt;/a&gt;: Runs integration tests, organized as unit tests that require external resources such as database connections.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/docker-compose.acceptance.yml&#34;&gt;docker-compose.acceptance.yml&lt;/a&gt;: Runs full-path acceptance tests, performing API calls and asserting results&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I used a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/Makefile&#34;&gt;Makefile&lt;/a&gt; to simplify some commonly used commands e.g. running tests, building binaries and deploying.&lt;/p&gt;

&lt;h2 id=&#34;nginx&#34;&gt;Nginx&lt;/h2&gt;

&lt;p&gt;My app doesn&amp;rsquo;t need any load balancing yet.  Rather, at this stage I employ Nginx for other features including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminating SSL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L29&#34;&gt;Redirecting HTTP -&amp;gt; HTTPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Serving static files and &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L44&#34;&gt;handling 304&lt;/a&gt; &amp;lsquo;Content Not Modifed&amp;rsquo; responses&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L12&#34;&gt;Gzipping responses&lt;/a&gt; when applicable&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L49&#34;&gt;Routing &amp;lsquo;/api/&amp;rsquo; requests&lt;/a&gt; to the backend.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m admittedly not an ops or Nginx configuration expert, so I owe a lot to The Google and Stackoverflow for getting this working.&lt;/p&gt;

&lt;p&gt;All nginx config is in the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf&#34;&gt;nginx/conf&lt;/a&gt; directory.&lt;/p&gt;

&lt;h2 id=&#34;reactjs-frontend-some-d3-js&#34;&gt;ReactJS Frontend (+ some D3.js)&lt;/h2&gt;

&lt;p&gt;I picked ReactJS mainly because of how simple it was to get up and going vs. other frameworks.  I wanted to write Go code, I didn&amp;rsquo;t want to spend my time learning what the perfect frontend framework is.  The less time for me spent on the frontend the better, but I also didn&amp;rsquo;t want to half-ass it&amp;hellip;  too badly.&lt;/p&gt;

&lt;p&gt;All ReactJS and other static files are packed with Nginx in the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/tree/v1.0/nginx/static&#34;&gt;nginx/static&lt;/a&gt; directory.  I used the free &lt;a href=&#34;https://startbootstrap.com/template-overviews/grayscale/&#34;&gt;grayscale&lt;/a&gt; bootsrap theme for CSS/layout.  The background picture I actually &lt;a href=&#34;https://www.flickr.com/photos/erby/19310748252/in/album-72157655281974332/&#34;&gt;took myself&lt;/a&gt; on a &lt;a href=&#34;https://www.flickr.com/photos/erby/albums/72157655281974332&#34;&gt;hike&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I use Webpack to build the app files into a single bundle.js.  My development docker-compose file was handy working on this because I could set webpack to watch changes and rebuild on the fly, and updating my changes in the container.&lt;/p&gt;

&lt;p&gt;The web page is a single-page app.  All paths on Nginx not matching &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L49&#34;&gt;&lt;code&gt;/api&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/conf/nginx.conf#L46&#34;&gt;valid path in the content directory&lt;/a&gt; serve the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/nginx/static/index.html&#34;&gt;index.html&lt;/a&gt; file.  This allows users to return to &amp;lsquo;pages&amp;rsquo; within the app courtesy of react-router&amp;rsquo;s functionality.  To demonstrate try going to the &lt;a href=&#34;https://freyr.erdmanczyk.com&#34;&gt;demo&lt;/a&gt;, logging in as the demo user, navigating to a chart, and then copying and pasting the url into a new browser tab.&lt;/p&gt;

&lt;p&gt;The app also includes charts, for which I chose &lt;a href=&#34;https://d3js.org/&#34;&gt;d3.js&lt;/a&gt;.  It&amp;rsquo;s easy to make fun of Javascript, but there are those who do make good things with it, and D3.js is one of those things.  It took some magic to get d3 to work with React, because of how React uses a virtual DOM representation, but some code from &lt;a href=&#34;https://github.com/Olical/react-faux-dom&#34;&gt;react-faux-dom&lt;/a&gt; came to the rescue.&lt;/p&gt;

&lt;h2 id=&#34;go-backend&#34;&gt;Go backend&lt;/h2&gt;

&lt;p&gt;Go powers the backend, the meat of the project, powering:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Negotiating &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/oauth/oauth.go#L66&#34;&gt;oauth&lt;/a&gt; with &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/oauth/google_oauth.go#L22&#34;&gt;Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Issuing signed &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/token/token.go#L39&#34;&gt;JWT&amp;rsquo;s&lt;/a&gt; to &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/middleware/authorized.go#L54&#34;&gt;authenticated users&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Authorizing &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/models/secret.go#L25&#34;&gt;HMAC signed&lt;/a&gt; web requests for &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/middleware/authorized.go#L93&#34;&gt;API access&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Receiving, storing, and serving &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/readings.go&#34;&gt;sensor readings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was the part I really cared about, by trade I consider myself a backend developer.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t do the intro to &amp;lsquo;What Go Is™&amp;rsquo; that seems obligatory on every blog post.&lt;/p&gt;

&lt;p&gt;I will say I have really enjoyed programming in Go.  Having a background in C, then C++, then Python working in Go has been a happy combination of what I&amp;rsquo;ve enjoyed between those worlds.  It&amp;rsquo;s got some problems to fix, but it gets a lot of things satisfyingly right.&lt;/p&gt;

&lt;p&gt;I could spend a whole couple blog posts talking about how I designed the Go backend, but instead I&amp;rsquo;ll just point at some key design features I chose writing it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using interfaces to model data sources: separating concerns in code, enabling mocking for unit tests, and allowing extensible swapping of data sources.&lt;/li&gt;
&lt;li&gt;No global config or config loading in libraries, only loading configuration in main and passing to components via parameters, which also enables easier unit testing.&lt;/li&gt;
&lt;li&gt;Sticking to the standard lib as much as possible (e.g. &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;net/http&lt;/a&gt;), making the code more reusable and less dependent on third party libraries.&lt;/li&gt;
&lt;li&gt;Using &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/middleware/authorized.go#L40&#34;&gt;contexts&lt;/a&gt; in http handlers.  I used the &lt;a href=&#34;https://github.com/cyclopsci/apollo&#34;&gt;apollo&lt;/a&gt; library for chaining, but need to switch to instead conform to context adaptations in Go 1.7+.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One example of how I used interfaces is with the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/models/readings.go#L17&#34;&gt;models.ReadingStore&lt;/a&gt; which is implemented by the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/database/reading.go#L9&#34;&gt;DB type&lt;/a&gt;.  When implementing handlers such as &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/readings.go#L67&#34;&gt;PostReadings&lt;/a&gt; and &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/readings.go#L93&#34;&gt;GetLatestReadings&lt;/a&gt;, the functions accept the interface type rather than DB.  This allowed me to test the handlers using a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/fake/reading.go#L43&#34;&gt;mock&lt;/a&gt; and the &lt;a href=&#34;https://golang.org/pkg/net/http/httptest/&#34;&gt;httptest&lt;/a&gt; package in &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/readings_test.go#L26&#34;&gt;readings_test.go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than using a framework such as &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;, &lt;a href=&#34;https://github.com/labstack/echo&#34;&gt;Echo&lt;/a&gt;, or even &lt;a href=&#34;http://www.gorillatoolkit.org/&#34;&gt;Gorilla&lt;/a&gt; (which actually plays very well with the stdlib) I chose to stick to the standard library as much as possible for handlers.  I only used &lt;a href=&#34;https://github.com/urfave/negroni&#34;&gt;negroni&lt;/a&gt; to easily get a couple handy middleware&amp;rsquo;s for free.  I didn&amp;rsquo;t want my project code heavily dependent on a third-party framework, lest I leave the project for a bit and come back to find the library deprecated or no longer compatible with updated language versions.  This also allows easier switching between libraries that also play nice the with standard library.&lt;/p&gt;

&lt;h2 id=&#34;ok-what-about-the-sensors&#34;&gt;Ok, what about the sensors?&lt;/h2&gt;

&lt;p&gt;I mentioned this app&amp;rsquo;s main purpose was to gather and log sensor data.  I also mentioned some security features.  How do those work together?&lt;/p&gt;

&lt;p&gt;I briefly hand-waved at the ability to verify API access via signed HTTP requests.  Once a user is logged in, they can access the &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/main.go#L66&#34;&gt;&lt;code&gt;/api/secret&lt;/code&gt;&lt;/a&gt; endpoint to get a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/secret.go#L11&#34;&gt;one-time-only private secret&lt;/a&gt;.  This can be used to access the API as their user by &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/middleware/authorized.go#L154&#34;&gt;signing the request in a certain way&lt;/a&gt;.  The secret can also be &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/routes/secret.go#L45&#34;&gt;rotated&lt;/a&gt; if needed.  I wrote a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/tree/v1.0/cmd/surtr&#34;&gt;CLI&lt;/a&gt; to convenience these operations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;You may notice I named my app &lt;a href=&#34;https://en.wikipedia.org/wiki/Freyr&#34;&gt;Freyr&lt;/a&gt; and CLI &lt;a href=&#34;https://en.wikipedia.org/wiki/Surtr&#34;&gt;surtr&lt;/a&gt;.  These are references to the Norse God and jötunn adversary at Ragnarok.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Currently the MCU I use enables registering a webhook for whenever data is posted using a provided firmware function.  This webhook can send a POST request to a specified endpoint, in this case &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/main.go#L70&#34;&gt;&lt;code&gt;/api/reading&lt;/code&gt;&lt;/a&gt;.  Unfortunately, their current functionality as of the time I was doing this work didn&amp;rsquo;t provide methods for request signing, so the best that could be done is to configure the webhook to include a &lt;a href=&#34;https://github.com/serdmanczyk/Freyr/blob/v1.0/token/token.go#L107&#34;&gt;signed JWT&lt;/a&gt; and headers with the POST request.  Admittedly not the most secure method, but given the amount of free-time I had(/have) it was a compromise for now that got me going.  I mean, people would look at what I&amp;rsquo;ve done already and awe themselves with my apparent amount of free-time.&lt;/p&gt;

&lt;h2 id=&#34;other-things-worth-mentioning&#34;&gt;Other things worth Mentioning&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04&#34;&gt;Free certs with LetsEncrypt!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Automated testing (because why not) with &lt;a href=&#34;https://travis-ci.org/serdmanczyk/Freyr&#34;&gt;Travis CI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/serdmanczyk/freyr&#34;&gt;A+ Go Report&lt;/a&gt; :)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/serdmanczyk/Freyr&#34;&gt;Godoc&lt;/a&gt; compliant&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;in-summary&#34;&gt;In Summary&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s a high level overview of the app, with a little more exposition on the Go pieces.  Hopefully this serves as a handy example to others working on similar projects.  In the future I look to add more features to this project, such as the ability to water plants and splitting the backend into smaller microservices.  All in time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Online Class Attendance App using Flask/MongoDB</title>
      <link>http://serdmanczyk.github.io/ClassAtttendanceApp/</link>
      <pubDate>Wed, 18 Jun 2014 00:00:00 UTC</pubDate>
      
      <guid>http://serdmanczyk.github.io/ClassAtttendanceApp/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/classattendance/Classes.png&#34; alt=&#34;Classes HomePage&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;My friends and I teach a parkour class at a local gymnastics gym, which we organize ourselves.  We needed a solid method for logging attendance.  There were many free solutions, but they all followed the attendance model similar to school classroom attendance: each class has assigned students and you mark attendance by checking them off as absent, tardy, attended, excused, etc.  This didn&amp;rsquo;t fit our model because we ran our class on a come-as-you-can basis.  For lack of a better solution we used an Excel Google Doc or just left our attendance logs on paper.&lt;/p&gt;

&lt;p&gt;Fast forward: not long ago I decided to take MongoDB&amp;rsquo;s free &lt;a href=&#34;https://university.mongodb.com/&#34;&gt;on-line developer&amp;rsquo;s course&lt;/a&gt;.  Part of the class used a simple blog example using the &lt;a href=&#34;http://bottlepy.org/docs/dev/index.html&#34;&gt;Bottle framework&lt;/a&gt; in Python, which made me think that a Python framework / MongoDB application would suit itself extremely well to what we wanted.  So I set to working using these tools to write my own simple class attendance application in my free time.&lt;/p&gt;

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;My final application is pieced together using the following components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask micro-framework&lt;/a&gt; to host the web interface, with &lt;a href=&#34;http://jinja.pocoo.org/docs/&#34;&gt;Jinja2&lt;/a&gt; to template web pages based on Python objects.&lt;/li&gt;
&lt;li&gt;Flask&amp;rsquo;s &lt;a href=&#34;https://pythonhosted.org/Flask-OAuth/&#34;&gt;Oauth plug-in&lt;/a&gt; to enable using Google OAuth for simple user authentication.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://api.mongodb.org/python/current/&#34;&gt;PyMongo&lt;/a&gt; to link the web framework to the &lt;a href=&#34;http://www.mongodb.org/&#34;&gt;MongoDB&lt;/a&gt; database.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://purecss.io/&#34;&gt;Pure CSS&lt;/a&gt; to simplify making the pages look &amp;lsquo;pretty.&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jqueryui.com/&#34;&gt;JQuery UI&lt;/a&gt; simplified adding handy interface features such as a javascript calendar to select class dates as well as student name auto-completion during attendance logging.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.openshift.com/&#34;&gt;OpenShift&lt;/a&gt; by RedHat for a free hosting solution easily managed by git and ssh.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;schema&#34;&gt;Schema&lt;/h1&gt;

&lt;p&gt;The MongoDB database schema uses four collections:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;authentication: contains Google Oauth credentials as well as the secret key for the application.&lt;/li&gt;
&lt;li&gt;coaches: contains all coaches as well as their e-mails to validate against Google Oauth login.&lt;/li&gt;
&lt;li&gt;students: holds all details about students such as emergency contacts, e-mail, birthdays, etc.&lt;/li&gt;
&lt;li&gt;classes: Contains all records of classes.  Each record contains a date and associates to the record for its indicated coach.  Within the record is a list of attendances with purchase info if applicable and an association to a student record for the attended student.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The schema for the student and classes collections are shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;# Students
{
    &#34;_id&#34; : ObjectId(&#34;53a0ee5b798a010258167aa7&#34;),
    &#34;firstname&#34; : &#34;Eunice&#34;,
    &#34;lastname&#34; : &#34;Anderson&#34;,
    &#34;gender&#34; : &#34;female&#34;,
    &#34;email&#34; : &#34;altheabanks@zensor.com&#34;
    &#34;dob&#34; : ISODate(&#34;1997-09-25T00:00:00Z&#34;),
    &#34;emergencyphone&#34; : &#34;+1 (949) 511-3347&#34;,
    &#34;emergencycontact&#34; : &#34;Althea Banks&#34;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;# Classes
{
    &#34;_id&#34; : ObjectId(&#34;53a0f734798a0110dc74abc1&#34;),
    &#34;date&#34; : ISODate(&#34;2014-01-01T00:00:00Z&#34;),
    &#34;coach&#34; : ObjectId(&#34;53a0ef10798a010f40e8cabc&#34;),
    &#34;type&#34; : &#34;beginner&#34;
    &#34;attendance&#34; : [
        {
            &#34;student&#34; : ObjectId(&#34;53a0ee5b798a010258167ab6&#34;)
        },
        {
            &#34;payment&#34; : {
                &#34;amount&#34; : 15,
                &#34;method&#34; : &#34;credit&#34;,
                &#34;purchased&#34; : &#34;drop in&#34;
            },
            &#34;student&#34; : ObjectId(&#34;53a0ee5b798a010258167ab5&#34;)
        },
        {
            &#34;payment&#34; : {
                &#34;amount&#34; : 0,
                &#34;method&#34; : &#34;punched&#34;,
                &#34;purchased&#34; : null
            },
            &#34;student&#34; : ObjectId(&#34;53a0ee5b798a010258167aaf&#34;)
        },
        ...
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/classattendance/Schema.png&#34; alt=&#34;Schema Diagram&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;screenshots&#34;&gt;Screenshots&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/classattendance/Class.png&#34; alt=&#34;Class Page&#34; /&gt;
&lt;img src=&#34;http://serdmanczyk.github.io/images/classattendance/Students.png&#34; alt=&#34;Students Page&#34; /&gt;
&lt;img src=&#34;http://serdmanczyk.github.io/images/classattendance/edit_student.png&#34; alt=&#34;Edit Student Page&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;demo-and-source-code&#34;&gt;Demo and Source Code&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://classdemo-evargreen.rhcloud.com/&#34; class=&#34;btn btn-success&#34;&gt;Live Demo&lt;/a&gt;    &lt;a href=&#34;https://github.com/serdmanczyk/parkour_class_attendance_app&#34; class=&#34;btn btn-success&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Editing on the demo is disabled, but forms buttons will still follow through to their final destinations.  Authorization through Google is still used, no user info is maintained, just a session token.  All student and coach data is random sample data generate using &lt;a href=&#34;http://www.json-generator.com/&#34;&gt;json-generator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All source code including provisions for OpenShift is available on GitHub.  Fork it and build it into your own class app!&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;This is just a quick base application I programmed for fun to get practice using new frameworks and technologies.  Future work includes adding more feedback to users when errors happend server-side.  Currently there&amp;rsquo;s no real error checking and only minor form validation.  If there&amp;rsquo;s an exception flask returns a feedback page, if a submit fails the new data simply fails to show up.  I would also add a page to manage coaches as well as an ability to view charts of attendance and revenue over time.  I may use a future post to demonstrate using MapReduce with MongoDB to retrieve related data from two collections in one call, similar to a SQL Join.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XBee API Mode Tutorial Using Python and Arduino</title>
      <link>http://serdmanczyk.github.io/XBeeAPI-PythonArduino-Tutorial/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 UTC</pubDate>
      
      <guid>http://serdmanczyk.github.io/XBeeAPI-PythonArduino-Tutorial/</guid>
      <description>

&lt;pre&gt;
Disclaimer:  This is meant to be a tutorial.
Primarily this is intended to educate with basic XBee
API mode setup, and how the XBee frame format works.
If you&#39;re looking for a library, I recommend for [XBee][pyxbee] for
Python and checkout [xbee-arduino][arxbee] for... yeah.
&lt;/pre&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This post is a tutorial, with example code, covering how to communicate using XBee 802.15.4 (Series 1) radios in API mode using Python and Arduino.  I decided to write these tutorials because I couldn&amp;rsquo;t find a substantial amount of simple examples when I decided to use XBee&amp;rsquo;s in API mode while working on my Masters thesis.  It&amp;rsquo;s my hopes this tutorial can help other people working on applications similar to mine get off the ground and running faster.&lt;/p&gt;

&lt;p&gt;Some knowledge of serial/UART communication mechanics, Python, and Arduino will be helpful for this tutorial but not absolutely required.  It&amp;rsquo;s hopeful that this tutorial can aid in your learning if you&amp;rsquo;re also picking these up as you go.  All example code is available at the &lt;a href=&#34;https://github.com/serdmanczyk/XBee_802.15.4_APIModeTutorial&#34; class=&#34;btn btn-success&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This tutorial does assume you are familiar with Digi X-CTU and Arduino software.  You will be instructed what to do in X-CTU and Arduino (e.g. &amp;ldquo;compile&amp;rdquo;, &amp;ldquo;change these settings&amp;rdquo;), but will not be instructed how to do it (e.g. &amp;ldquo;push the blue button&amp;rdquo;, &amp;ldquo;go to menu File-&amp;gt;&amp;rdquo;)&lt;/p&gt;

&lt;h2 id=&#34;requisite-hardware&#34;&gt;Requisite Hardware&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2 XBee 802.15.4 Series 1 radios&lt;/li&gt;
&lt;li&gt;1 XBee 3.3v-5v adapter / break-out board&lt;/li&gt;
&lt;li&gt;1 XBee USB adapter&lt;/li&gt;
&lt;li&gt;1 Arduino board (This tutorial was written with an &lt;a href=&#34;https://www.sparkfun.com/products/11021&#34;&gt;Uno&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;1 Breadboard and jumper wires&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I recommend the &lt;a href=&#34;http://amzn.com/B00B6SF2C6&#34;&gt;Parallax XBee Wireless Pack&lt;/a&gt;, but there are also several other options on &lt;a href=&#34;https://www.sparkfun.com&#34;&gt;SparkFun&lt;/a&gt;, &lt;a href=&#34;https://www.adafruit.com&#34;&gt;Adafruit&lt;/a&gt;, &lt;a href=&#34;http://www.makershed.com/SearchResults.asp?Search=xbee&#34;&gt;Maker Shed&lt;/a&gt; and other hobby electronics stores.  Many of them are very similar to the pieces used in this post.&lt;/p&gt;

&lt;h2 id=&#34;requisite-software&#34;&gt;Requisite Software&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/xctu&#34;&gt;Digi X-CTU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ftdichip.com/FTDrivers.htm&#34;&gt;FTDI Drivers&lt;/a&gt; (for USB to Serial communications)&lt;/li&gt;
&lt;li&gt;Python &lt;a href=&#34;https://www.python.org/download/releases/2.7.7/&#34;&gt;2.7&lt;/a&gt; or &lt;a href=&#34;https://www.python.org/download/releases/3.3.5&#34;&gt;3.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pyserial.sourceforge.net/&#34;&gt;PySerial library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://arduino.cc/en/main/software&#34;&gt;Arduino Software&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;why-xbee-802-15-4&#34;&gt;Why XBee 802.15.4?&lt;/h2&gt;

&lt;p&gt;XBee radios are handy in embedded applications because they enable wireless communications with relatively low power compared to Wi-Fi, bluetooth, or cellular technologies at the cost of slower speed.  XBee 802.15.4 (Series 1) provides simple OSI layer one and two functionality on the module.  Zigbee radios (XBee Series 2) provide an additional networking layer that can handle cool things like automatic mesh networking, however, Zigbee mesh networks are limited to a maximum of 10 nodes.  Zigbee radios can also operate in API mode, frame packaging is the same, and the frames used for Zigbee are very similar.  This tutorial covers XBee 80.15.4 because their frames are simpler for beginners and are all we need to cover the basics.&lt;/p&gt;

&lt;h2 id=&#34;why-xbee-api-mode-a-brief-review&#34;&gt;Why XBee API mode? A Brief Review&lt;/h2&gt;

&lt;p&gt;Using API mode to communicate has a few advantages compared to other XBee configuration options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No need for timely switching in/out of command mode to change configuration options&lt;/li&gt;
&lt;li&gt;Message destination addresses can be specified on the fly&lt;/li&gt;
&lt;li&gt;Received message frames come packaged with an RSSI (Received Signal Strength Indicator) byte&lt;/li&gt;
&lt;li&gt;Feedback is provided on message transmission success when enabled&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In API mode, all incoming and outgoing messages are required to be packaged in frames.  The picture below summarizes a few of the basic frame types based on descriptions in the &lt;a href=&#34;http://ftp1.digi.com/support/documentation/90000982_N.pdf&#34;&gt;XBee 802.15.4 product manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/XBeeFramesOverview.png&#34; alt=&#34;API Frames Summary&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each frame has a minimum of the the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Start delimiter byte &lt;code&gt;0x7E&lt;/code&gt; &lt;em&gt;&amp;ldquo;there is a frame here&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Most Significant Byte (MSB) &lt;em&gt;&amp;ldquo;the start byte is at: &amp;ldquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Least Significant Byte (LSB) &lt;em&gt;&amp;ldquo;the end byte is at: &amp;ldquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;API identifier (cmdID) &lt;em&gt;&amp;ldquo;the content looks like: &amp;ldquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Frame data (including additional bytes specific to API message type)&lt;/li&gt;
&lt;li&gt;Checksum byte &lt;em&gt;&amp;ldquo;all contents compress to: &amp;ldquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The start delimiter simply denotes the beginning of a frame.  The MSB and LSB are used to indicate the length of the data in the frame.  The length of the frame is the number of bytes after the LSB, not including the checksum byte.  The MSB is always 0x00, so the LSB will be equivalent to the length.  Every frame will have an API identifier specifying what type of frame is being sent (this tutorial will cover the 16-bit address transmit and receive message types).  After the API identifier comes any additional bytes required by the specified frame type. After that is the actual frame data (in the case of a transmit and receive frame, the data to transmit/received).  The checksum byte is used to verify the integrity of the contents.  The checksum is calculate using the following process:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sum value of each byte after LSB&lt;/li&gt;
&lt;li&gt;Preserve only the lower 8 bits (AND with &lt;code&gt;0xFF&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Subtract the value from 255&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This enables simple verification of received frames because the lower 8 bits of the sum of all bytes after the LSB (including the checksum) will be equal to 255 or &lt;code&gt;0xFF&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After formatting the previous parts, a final step is necessary if you&amp;rsquo;re using API mode with escaped characters.  When escaping is enabled, any bytes (excluding the start delimiter) that contain reserved characters (&lt;code&gt;0x7E&lt;/code&gt;, &lt;code&gt;0x7D&lt;/code&gt;, &lt;code&gt;0x11&lt;/code&gt;, and &lt;code&gt;0x13&lt;/code&gt;) must be escaped so that the XBee will not interpret them as control characters.  This may seem like extra overhead, but escaped mode simplifies message reception so that you can count on any &lt;code&gt;0x7E&lt;/code&gt; byte to only indicate a start delimiter (or an ignorable error).  This removes the need to program for more edge cases and simplifies code.&lt;/p&gt;

&lt;p&gt;To escape a message, anywhere in the message (including the MSB, LSB, and checksum bytes) a reserved character appears, it should be replaced with an &lt;code&gt;0x7D&lt;/code&gt; escape character followed by the original character XOR&amp;rsquo;ed with &lt;code&gt;0x20&lt;/code&gt;.  For example the bytes &lt;code&gt;00 11 23&lt;/code&gt; after escaping would become &lt;code&gt;00 7D 31 23&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, in a nutshell, the process for formatting an API frame is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Calculate the full length of the message (minus start delimiter and checksum) and insert it as the LSB&lt;/li&gt;
&lt;li&gt;Calculate and insert any bytes necessary for the API frame type&lt;/li&gt;
&lt;li&gt;Calculate the checksum and place it at the end of the frame&lt;/li&gt;
&lt;li&gt;Escape any reserved characters (including MSB, LSB, and checksum)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That covers the basics of API frames / the boring part.  Now let&amp;rsquo;s actually have some fun.&lt;/p&gt;

&lt;h2 id=&#34;part-one-initial-setup-and-communication-in-transparent-mode&#34;&gt;Part One: Initial Setup and communication in Transparent Mode&lt;/h2&gt;

&lt;p&gt;For all parts of this tutorial we&amp;rsquo;ll have two XBee radios with different settings.  To make things easier we&amp;rsquo;ll give them names.  For the rest of this tutorial &amp;ldquo;Atreyu&amp;rdquo; will refer to the XBee we&amp;rsquo;re connecting to our computer and &amp;ldquo;Falcor&amp;rdquo; will refer to the XBee we&amp;rsquo;re connecting to our Arduino.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/Setup_Diagram.png&#34; alt=&#34;Setup Diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We will start with both XBee&amp;rsquo;s in transparent mode.  Atreyu will connect to the X-CTU console on our computer, and Falcor will be wired in passthrough mode so that it will reflect any messages sent to it directly back to Atreyu.&lt;/p&gt;

&lt;p&gt;First we need to configure the proper parameters on the radios so they will talk to each other.  For both radios, use X-CTU to load the default parameters, and then configure/write the following settings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|                   Settings for Atreyu                |
| Name                            | Value              |
|:-----------------------------   | -----------------: |
| `MY` (16-bit source address)    | `0`                |
| `DH` (Destination Address High) | `0`                |
| `DL` (Destination Address Low)  | `1`                |
| `AP` (API Enable)               | `API Disabled [0]` |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|                   Settings for Falcor                  |
| Name                            | Value                |
|:-----------------------------   | -------------------: |
| `MY`                            | `1`                  |
| `DH`                            | `0`                  |
| `DL`                            | `0`                  |
| `AP`                            | `API Disabled [0]`   |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Leave Atreyu connected to the computer with the X-CTU software.  Insert Falcor into your 3.3v-5v adapter/break-out board and connect the following pins from the break-out board:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connect the DIN pin to DOUT (passthrough)&lt;/li&gt;
&lt;li&gt;Connect 5v and GND to a 5v power source&lt;/li&gt;
&lt;li&gt;That&amp;rsquo;s it!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you like, you can use the Arduino as an overly fanciful power supply.  We will be using it in Part Three, so this way we&amp;rsquo;ll only need to modify one wire when we start communicating with the Arduino.  Connect the Arduino to power (computer USB, or DC-in from wall or a battery) and it will provide enough current through the 5v pin to power the XBee.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/XBeePassThroughGraphic.png&#34; alt=&#34;XBee Pass-Through Mode Connection&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The illustration shows a SparkFun XBee explorer module because it is what is available in &lt;a href=&#34;http://fritzing.org/home/&#34;&gt;fritzing&lt;/a&gt;.  The pin layout is identical to the module in the Parallax kit.
{: .notice}&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve set this up correctly, you should now be able to connect to Atreyu with the X-CTU console and start typing text and see it returned like below (Blue text is sent, Red is received).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/HelloWorld_Passive.png&#34; alt=&#34;Passive Hello World&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Congratulations!  You&amp;rsquo;ve successfully setup and communicated with the XBee&amp;rsquo;s in transparent mode.  Now we&amp;rsquo;re ready to switch Atreyu into API mode and start communicating using Python in part two.&lt;/p&gt;

&lt;h2 id=&#34;part-two-communicating-from-a-pc-w-api-mode-using-python&#34;&gt;Part Two: Communicating from a PC w/API mode using Python&lt;/h2&gt;

&lt;p&gt;Now that we have things setup and we&amp;rsquo;ve verified they can communicate, we can switch our first XBee into API mode and begin sending messages with it via Python. Re-configure the following parameter on Atreyu to enable API mode.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|        Settings for Atreyu        |
| Name    | Value                   |
| :-----  | -------------------:    |
| `AP`    | `API enabled w/PPP [2]` |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test in X-CTU, you can create a packet with following Hex contents: &lt;code&gt;7E 00 10 01 00 FF FF 01 48 65 6C 6C 6F 20 57 6F 72 6C 64 E3&lt;/code&gt; (You can copy and paste).  You should be able to send the example packet in the X-CTU console and get a response (still being reflected from Falcor) identical to the second image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/APIHelloWorldPacket.png&#34; alt=&#34;API Hello World Packet&#34; /&gt;
&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/APIHelloWorldResponse.png&#34; alt=&#34;API Hello World Response&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Congratulations!  You&amp;rsquo;ve sent your first message with XBee API mode.  Now let&amp;rsquo;s send a package using Python.&lt;/p&gt;

&lt;p&gt;Go ahead and clone the GitHub repository for this tutorial if you haven&amp;rsquo;t already.  Also, make sure you have installed PySerial as well.  Now navigate to the Python folder.  You will need to modify line 5 in main.py to match the port your XBee resides on.  Now if you navigate with a command prompt to this folder and run main.py your command prompt output should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ C:/.../main.py
Tx: 7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3
Rx: 7e 00 10 81 00 01 24 00 48 65 6c 6c 6f 20 57 6f 72 6c 64 3d
Msg: Hello World
Tx: 7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 7d 5e
Rx: 7e 00 7d 31 81 00 01 24 00 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 d8
Msg: 7e 7d 11 13 5b 01 01 01 01 01 01 01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You did it!  What exactly did we do?  Let&amp;rsquo;s start examining the code by looking at the body of main.py.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;    xbee = XBee.XBee(&#34;COM3&#34;)  # Your serial port name here

    # A simple string message
    sent = xbee.SendStr(&#34;Hello World&#34;)
    sleep(0.25)
    Msg = xbee.Receive()
    if Msg:
        content = Msg[7:-1].decode(&#39;ascii&#39;)
        print(&#34;Msg: &#34; + content)

    # A message that requires escaping
    xbee.Send(bytearray.fromhex(&#34;7e 7d 11 13 5b 01 01 01 01 01 01 01&#34;))
    sleep(0.25)
    Msg = xbee.Receive()
    if Msg:
        content = Msg[7:-1]
        print(&#34;Msg: &#34; + xbee.format(content))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen, we sent and received two messages.  The first messages contents were simply &amp;ldquo;Hello World&amp;rdquo; in ascii encoding.  The second message is a bit more obscure, it is formatted to demonstrate API mode character escaping which we&amp;rsquo;ll get more into soon.  Now, let&amp;rsquo;s get into the pieces that are the heart of this tutorial.  Lets start with the XBee &lt;code&gt;__init__()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class XBee():
    ...
    def __init__(self, serialport, baudrate=9600):
        self.serial = serial.Serial(port=serialport, baudrate=baudrate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the class constructor does is initialize the serial port.  You can read more on PySerial options in the &lt;a href=&#34;http://pyserial.sourceforge.net/pyserial_api.html&#34;&gt;PySerial API documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now lets look at the interesting stuff, starting with the SendStr() method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;    def SendStr(self, msg, addr=0xFFFF, options=0x01, frameid=0x00):
        return self.Send(msg.encode(&#39;utf-8&#39;), addr, options, frameid)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;SendStr()&lt;/code&gt; simply decodes the message into a bytes object using UTF-8 encoding and passes it to the &lt;code&gt;Send()&lt;/code&gt; method.  If you&amp;rsquo;re only using characters from the ascii set they will only require one byte per character.&lt;/p&gt;

&lt;p&gt;What is a bytes object?  A bytes object is basically an array of integers with values between 0-255, so literally: bytes. You can read up more on bytes and bytearrays in the &lt;a href=&#34;https://docs.python.org/3.1/library/stdtypes.html#bytes-methods&#34;&gt;Python documentation&lt;/a&gt; and &lt;a href=&#34;http://dabeaz.blogspot.com/2010/01/few-useful-bytearray-tricks.html&#34;&gt;this helpful blog post&lt;/a&gt;.  Bytes and bytearray objects are the required inputs for the PySerial library.  A bytearray is basically the same as a bytes object, except mutable.  Now lets look at the &lt;code&gt;Send()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def Send(self, msg, addr=0xFFFF, options=0x01, frameid=0x00):
        if not msg:
            return 0

        hexs = &#39;7E 00 {:02X} 01 {:02X} {:02X} {:02X} {:02X}&#39;.format(
            len(msg) + 5,           # LSB (length)
            frameid,
            (addr &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8,   # Destination address high byte
            addr &amp;amp; 0xFF,            # Destination address low byte
            options
        )

        frame = bytearray.fromhex(hexs)
        #  Append message content
        frame.extend(msg)

        # Calculate checksum byte
        frame.append(0xFF - (sum(frame[3:]) &amp;amp; 0xFF))

        # Escape any bytes containing reserved characters
        frame = self.Escape(frame)

        print(&amp;quot;Tx: &amp;quot; + self.format(frame))
        return self.serial.write(frame)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Send()&lt;/code&gt; accepts &amp;lsquo;msg&amp;rsquo; as its first parameter, which is expected to be a bytes or bytearray object.  Optionally you can specify an address, options, or a frameid but the defaults are to broadcast, disable acknowledgments, and have no frameid.&lt;/p&gt;

&lt;p&gt;The first thing the &lt;code&gt;Send()&lt;/code&gt; method does is initialize a transmit request frame in a bytearray object.  It first formats a string that contains the desired hex characters using string formatting operations.  This isn&amp;rsquo;t the most efficient way, but it makes things more readable.  Then the bytearray &lt;code&gt;fromhex()&lt;/code&gt; method will decode the string into a bytearray object e.g. &lt;code&gt;bytearray.fromhex()&lt;/code&gt; with the strings &lt;code&gt;&amp;quot;7E 00&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;7E00&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot; 7e00&amp;quot;&lt;/code&gt;, and &lt;code&gt;&amp;quot;7e00 &amp;quot;&lt;/code&gt; will all create a bytearray object with bytes &lt;code&gt;[0x7E, 0x00]&lt;/code&gt;.  We use this method to input our LSB, frameid, address, and options bytes (MSB is always zero).  Our LSB is equivelant to the length of our frame between the LSB and checksum or rather the length of the message contents plus 5 bytes: the API type, frameid, address, and options bytes required for a transmission request frame.&lt;/p&gt;

&lt;p&gt;Next the function extends the frame to contain our message.  Then the checksum is calculate and appended to the end.  Now that our frame is formatted, we escape any reserved characters after the start delimiter using the &lt;code&gt;Escape()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def Escape(self, msg):
        escaped = bytearray()
        reserved = bytearray(b&amp;quot;\x7E\x7D\x11\x13&amp;quot;)

        escaped.append(msg[0])
        for m in msg[1:]:
            if m in reserved:
                escaped.append(0x7D)
                escaped.append(m ^ 0x20)
            else:
                escaped.append(m)

        return escaped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After escaping, the message is ready to send!  The &lt;code&gt;Send()&lt;/code&gt; function prints the formatted frame for debug using the &lt;code&gt;format()&lt;/code&gt; function, and then passes it to the serial port with the PySerial &lt;code&gt;write()&lt;/code&gt; method.  The &lt;code&gt;format()&lt;/code&gt; function is just a simple function to convert a byte object into a more readable string for debug output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def format(self, msg):
        return &amp;quot; &amp;quot;.join(&amp;quot;{:02x}&amp;quot;.format(b) for b in msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a breakdown of the contents of the formatted frames for the two messages in main.py:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Msg: Hello World ------------------------------------------------------------------------------
                                                                Checksum |
                                        -  &amp;quot;hello world&amp;quot; in Ascii -      |
                             Options |                                   |
                      Address LSB |  |                                   |
                   Address MSB |  |  |                                   |
                   Frame ID |  |  |  |                                   |
              Tx Request |  |  |  |  |                                   |
                  LSB |  |  |  |  |  |                                   |
               MSB |  |  |  |  |  |  |                                   |
start delimiter |  |  |  |  |  |  |  |                                   |
                |  |  |  |  |  |  |  |                                   |
                7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3


Msg: 7e 7d 11 13 5b 01 01 01 01 01 01 01 ------------------------------------------------------
                                                                           Escaped Checksum |
                                Options |                                                   |
                         Address LSB |  |                                                   |
                      Address MSB |  |  |                                                   |
                      Frame ID |  |  |  |                                                   |
                 Tx Request |  |  |  |  |                                                   |
          LSB Escaped |     |  |  |  |  |                                                   |
               MSB |  |     |  |  |  |  |                                                   |
start delimiter |  |  |     |  |  |  |  |                                                   |
                7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 7d 5e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can see, the second message is specially designed so the LSB and checksum bytes in the formatted frame require escaping, just to demonstrate that necessity (and that it works).&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it for sending a message.  The next step is to receive the message.  This gets a bit more complicated.  When you receive through serial, it&amp;rsquo;s not guaranteed that the entire message will come through at once.  You also may get the beginning of another message.  It&amp;rsquo;s important to receive as much as possible in a call, parse out any messages, and hold onto any remaining bytes until the next time your program attempts to receive.  This is done in the example code &lt;code&gt;Receive()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def Receive(self):
        remaining = self.serial.inWaiting()
        while remaining:
            chunk = self.serial.read(remaining)
            remaining -= len(chunk)
            self.RxBuff.extend(chunk)

        msgs = self.RxBuff.split(bytes(b&#39;\x7E&#39;))
        for msg in msgs[:-1]:
            self.Validate(msg)

        self.RxBuff = (bytearray() if self.Validate(msgs[-1]) else msgs[-1])

        if self.RxMessages:
            return self.RxMessages.popleft()
        else:
            return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code first receives any data available on the serial port.  Thanks to python, we can easily &amp;lsquo;split&amp;rsquo; the buffer around the &lt;code&gt;0x7E&lt;/code&gt; start delimiter into a list of bytearrays then iterate through them.  Each call to &lt;code&gt;Validate()&lt;/code&gt; will append the message to the &lt;code&gt;RxMessages&lt;/code&gt; if the message validates.  If the last message doesn&amp;rsquo;t validate, it may be the beginning of a new message, so the method holds onto it until the next call.&lt;/p&gt;

&lt;p&gt;With this code, if you send data and call &lt;code&gt;Receive()&lt;/code&gt; immediately, the response message will not be ready in the serial buffer yet.  Python code runs much faster than the 9600 baud rate at which the serial port is operating.  Because of this it&amp;rsquo;s necessary to pause at least the minimum amount of time it takes the message to transmit, the source to process/respond, and the radio to receive/send the message back to our program.  This is why main.py sleeps for &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; second after sending.  In production code it may be more reasonable to use callbacks or threading, but that&amp;rsquo;s beyond the scope of this tutorial; we&amp;rsquo;ll keeping it simple.  Still, there is an alternate version of XBee.py with threads and thread-safe Queues for message reception in the repository if you&amp;rsquo;re interested.
{: .notice}&lt;/p&gt;

&lt;p&gt;For each start delimiter found in the receive buffer, the &lt;code&gt;validate()&lt;/code&gt; method is called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def Validate(self, msg):
        # 9 bytes is Minimum length to be a valid Rx frame
        #  LSB, MSB, Type, Source Address(2), RSSI,
        #  Options, 1 byte data, checksum
        if (len(msg) - msg.count(bytes(b&#39;0x7D&#39;))) &amp;lt; 9:
            return False

        # All bytes in message must be unescaped before validating content
        frame = self.Unescape(msg)

        LSB = frame[1]
        # Frame (minus checksum) must contain at least length equal to LSB
        if LSB &amp;gt; (len(frame[2:]) - 1):
            return False

        # Validate checksum
        if (sum(frame[2:3+LSB]) &amp;amp; 0xFF) != 0xFF:
            return False

        print(&amp;quot;Rx: &amp;quot; + self.format(bytearray(b&#39;\x7E&#39;) + msg))
        self.RxMessages.append(frame)
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing the &lt;code&gt;Validate()&lt;/code&gt; method does is double check the message array (minus any escapes) is at least the size required for a message.  The next thing it does is undo any escape characters with the &lt;code&gt;Unescape()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def Unescape(self, msg):
        if msg[-1] == 0x7D:
            # Last byte indicates an escape, can&#39;t unescape that
            return None

        out = bytearray()
        skip = False
        for i in range(len(msg)):
            if skip:
                skip = False
                continue

            if msg[i] == 0x7D:
                out.append(msg[i+1] ^ 0x20)
                skip = True
            else:
                out.append(msg[i])

        return out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to do this before the next steps to read the LSB and checksum bytes.  Then the &lt;code&gt;Validate()&lt;/code&gt; method double checks the current frame length is at least the size indicated by the LSB.  If it is, the last step in validation is to verify the checksum by summing all characters from the LSB up to the checksum and making sure the lower byte is equal to &lt;code&gt;0xFF&lt;/code&gt;.  If all this checks out, we have a valid message!  The message is now printed for debug output and placed in the &lt;code&gt;RxMessages&lt;/code&gt; list member variable.&lt;/p&gt;

&lt;p&gt;That concludes all the example pieces to do basic message sending and receiving in API mode using Python.  Next, we&amp;rsquo;ll switch worlds into C++ code to handle message reception on an Arduino.&lt;/p&gt;

&lt;h2 id=&#34;part-three-communicating-from-an-arduino-w-api-mode&#34;&gt;Part Three: Communicating from an Arduino w/API mode&lt;/h2&gt;

&lt;p&gt;Now we&amp;rsquo;ll need to re-connect Falcor to our computer briefly to reset the following parameters in X-CTU:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|        Settings for Falcor        |
| Name    | Value                   |
| :-----  | -------------------:    |
| `AP`    | `API enabled w/PPP [2]` |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now return Falcor to the 3.3v-5v breakout board but don&amp;rsquo;t wire it yet.&lt;/p&gt;

&lt;p&gt;Before wiring the Arduino to the XBee, we&amp;rsquo;ll need to load our software onto the board.  The Arduino software should recognize the Arduino.ini file, once loaded simply compile and load the program onto your board.  Once it&amp;rsquo;s programmed, disconnect the Arduino and wire the XBee to it like so:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connect DOUT (3 from top left) to port 12 on Arduino&lt;/li&gt;
&lt;li&gt;Connect DIN (4 from top left) to port 13 on Arduino&lt;/li&gt;
&lt;li&gt;Leave 5v and GND connect as before (if you used Arudino as power source, otherwise, connect them to Arduino 5v,GND)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/xbeetut/XBeeArduinoGraphic.png&#34; alt=&#34;Passive Hello World&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re using pins 12, 13 as our Rx, Tx pins respectively using the SoftwareSerial library.  This frees up the default Tx,Rx pins to send debug data to our computer if you like.  This also allows you to communicate while plugged into your computer port, otherwise the Arduino serial would be occupied by the connection to your computer.  In realistic applications you would want to use a hardware serial port with its own UART.&lt;/p&gt;

&lt;p&gt;Assuming everything is plugged in, you can go back to your console from Part Two and run main.py again.  You should get an output that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ C:/.../main.py
Tx: 7e 00 10 01 00 ff ff 01 48 65 6c 6c 6f 20 57 6f 72 6c 64 e3
Rx: 7e 00 1a 81 00 01 18 00 79 6f 75 20 73 65 6e 74 3a 20 48 65 6c 6c 6f 20 57 6f 72 6c 64 b8
Msg: you sent: Hello World
Tx: 7e 00 7d 31 01 00 ff ff 01 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 FIFO 01 7d 5e
Rx: 7e 00 1b 81 00 01 1a 00 79 6f 75 20 73 65 6e 74 3a 20 7d 5e 7d 5d 7d 31 7d 33 5b 01 01 01 01 01 01 01 51
Msg: 79 6f 75 20 73 65 6e 74 3a 20 7e 7d 11 13 5b 01 01 01 01 01 01 01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice it&amp;rsquo;s the same content as earlier, except now our returned messages have &amp;ldquo;you sent: &amp;ldquo; appended to the front.  The Arduino is now receiving, editing, and then returning our messages.&lt;/p&gt;

&lt;p&gt;So there it is, you&amp;rsquo;ve now sent and received data in API mode with Python and Arduino.  New doors will open and bells will ring as you celebrate this wondrous day.  I&amp;rsquo;ll let you call your parents and tell them, but when you&amp;rsquo;re done let&amp;rsquo;s review the code.&lt;/p&gt;

&lt;p&gt;As before, we&amp;rsquo;ll begin with our main code in Arduino.ino.  First the setup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XBee xbee;
Queue RxQ;
SoftwareSerial sserial(12,13);

void setup(void)
{
    sserial.begin(9600);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We instantiate an instance of the XBee, Queue, and SoftwareSerial classes.  We&amp;rsquo;ll go more into detail on the XBee class soon.  The Queue is a C++ implementation of a standard FIFO queue for the unsigned char data type, with a couple home-brewed helper methods to aid in this application.  If that sounds unfamiliar, google &amp;ldquo;FIFO queue&amp;rdquo; and read up on them, it&amp;rsquo;s a handy data structure.  One of the most basic.  We&amp;rsquo;ll use the queue as our receive buffer.  The only code in our &lt;code&gt;setup()&lt;/code&gt; method is to start off our serial connection at 9600 baud.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void loop(void)
{
    delay(5);
    int queueLen = 0;
    int delPos = 0;

    while (sserial.available() &amp;gt; 0){
        unsigned char in = (unsigned char)sserial.read();
        if (!RxQ.Enqueue(in)){
            break;
        }
    }

    queueLen = RxQ.Size();
    for (int i=0;i&amp;lt;queueLen;i++){
        if (RxQ.Peek(i) == 0x7E){
            unsigned char checkBuff[Q_SIZE];
            unsigned char msgBuff[Q_SIZE];
            int checkLen = 0;
            int msgLen = 0;

            checkLen = RxQ.Copy(checkBuff, i);
            msgLen = xbee.Receive(checkBuff, checkLen, msgBuff);
            if (msgLen &amp;gt; 0){
                unsigned char outMsg[Q_SIZE];
                unsigned char outFrame[Q_SIZE];
                int frameLen = 0;
                int addr = ((int)msgBuff[4] &amp;lt;&amp;lt; 8) + (int)msgBuff[5];

                // 10 is length of &amp;quot;you sent: &amp;quot;
                memcpy(outMsg, &amp;quot;you sent: &amp;quot;, 10);
                // len - (9 bytes of frame not in message content)
                memcpy(&amp;amp;outMsg[10], &amp;amp;msgBuff[8], msgLen-9);

                // 10 + (-9) = 1 more byte in new content than in previous message
                frameLen = xbee.Send(outMsg, msgLen+1, outFrame, addr);
                sserial.write(outFrame, frameLen);
                i += msgLen;
                delPos = i;
            }else{
                if (i&amp;gt;0){
                    delPos = i-1;
                }
            }
        }
    }

    RxQ.Clear(delPos);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot to take in real quick, but don&amp;rsquo;t be too intimidated.  This is what is going on in the &lt;code&gt;loop()&lt;/code&gt; method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A small 5ms delay, to give the serial time to do work.&lt;/li&gt;
&lt;li&gt;Check the serial buffer for content.  If any is available, read it into the queue.&lt;/li&gt;
&lt;li&gt;Parse through the queue for a start delimiter.&lt;/li&gt;
&lt;li&gt;If a delimiter is found, check if the content after the delimiter is a proper message using &lt;code&gt;XBee.Receive()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If the content is valid, create a new message to send.&lt;/li&gt;
&lt;li&gt;New message is &amp;ldquo;you sent: &amp;ldquo; + content of received message.  Message is created using &lt;code&gt;XBee.Send()&lt;/code&gt; using address parsed from incoming frame, then sent using the &lt;code&gt;write()&lt;/code&gt; call to SoftwareSerial.&lt;/li&gt;
&lt;li&gt;After parsing is done the delPos variable stores off the last location of possible good/unused data in the queue, it is used to clear any unneeded contents.  We may not have received the full portion of a message yet, so we&amp;rsquo;ll hold on to any we may still want.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The code makes liberal use of buffers to keep code &amp;lsquo;simpler&amp;rsquo; as lengths vary between the data in the queue, the read message and output messages.  Algorithmically there&amp;rsquo;s definitely more efficient ways to do this, but that would be hell to read for a tutorial.  Something more eye friendly could possibly be written with other Arduino libraries such as String, but as a guy used to using C in embedded applications I stuck to what I know.  Maybe an optimization for a future version :).&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s once again get to the guts of our code.  All of the main parts should look very familiar.  It&amp;rsquo;s basically carbon copies of the Python methods, except with C-friendly data structures.  I won&amp;rsquo;t add too much wordiness to the tutorial by re-explaining how things work, so I&amp;rsquo;ll just put the code here to peruse.  But just for a quick re-hash:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Receive()&lt;/code&gt; validates content to ensure it is a proper message&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unescape()&lt;/code&gt; parses out escaped characters to their original content&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Send()&lt;/code&gt; Takes input content and places it into a Tx request frame (the calling method is expected to send it)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;escape()&lt;/code&gt; takes an input buffer and escapes any reserved characters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All XBee methods count on the calling class to provide the input and output buffers.  For all buffer sizes we&amp;rsquo;re using the Q_SIZE defined in our Queue class, since that&amp;rsquo;s the max data we&amp;rsquo;ll encounter.  The size is set to 220, a comfortable size larger than the max XBee message size of 100.  This, of course, assumes you may only receive max one 100 byte frame at a time.  This size is safe for simple applications such as this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int XBee::Receive(unsigned char *inBuff, int len, unsigned char *outBuff){
    int unescapeLen = 0;
    unsigned char checksum = 0;
    unsigned char LSB = 0;

    if (inBuff[0] != 0x7E)
        return 0;

    if (len &amp;lt; 10)
        return 0;

    unescapeLen = unescape(inBuff, len, outBuff);

    // Check we have at least the amount of bytes indicated by LSB
    LSB = outBuff[2];
    if (LSB &amp;gt; (unescapeLen - 4))
        return 0;

    // Calculate our checksum
    // (char will overflow, no need to AND for lower bytes)
    for (int i=3; i&amp;lt;LSB+4; i++){
        checksum += outBuff[i];
    }

    if (checksum != 0xFF)
        return 0;

    return LSB+4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;
    bool skip = false;
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i&amp;lt;inLen; i++) {
        if (skip){
            skip = false;
            continue;
        }

        if (input[i] == 0x7D){
            curr = input[i+1] ^ 0x20;
            skip = true;
        }else{
            curr = input[i];
        }

        output[pos] = curr;
        pos++;
    }

    return pos;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;int XBee::Send(unsigned char *msg, int len, unsigned char *outBuff, int addr){
    unsigned char buf[100];
    int escapedLen = 0;
    unsigned char checksum = 0;

    buf[0] = 0x7E;
    buf[1] = 0x00;
    // LSB = content + 5 (content length + API type + frameid + addr(2) + options)
    buf[2] = (unsigned char)(len + 5);
    buf[3] = 0x01;  // transmit request
    buf[4] = 0x00;  // Frame ID
    buf[5] = (unsigned char)((addr &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8);
    buf[6] = (unsigned char)(addr &amp;amp; 0xFF);
    buf[7] = 0x01;  // Disable acknowledge
    memcpy(&amp;amp;buf[8], msg, len);

    for (int i=3;i&amp;lt;len+8;i++){
        checksum += buf[i];
    }

    // Total length = LSB + 9 (LSB value + MSB + LSB + start delimiter + checksum)
    buf[len+8] = 0xFF - checksum;
    escapedLen = escape(buf, len+9, outBuff);

    return escapedLen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;

    output[0] = input[0];
    for (int i=1; i&amp;lt;inLen; i++){
        switch(input[i]){
            case 0x7D:
            case 0x7E:
            case 0x11:
            case 0x13:
                output[pos++] = 0x7D;
                output[pos++] = input[i] ^ 0x20;
                break;
            default:
                output[pos++] = input[i];
                break;
      }
   }

   return pos;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That sums up all the main parts of the XBee example code.&lt;/p&gt;

&lt;h2 id=&#34;review&#34;&gt;Review&lt;/h2&gt;

&lt;p&gt;That covers a basic example of programming for XBee 802.15.4 radios configured in API mode.  I found API mode very helpful when programming for my Masters thesis, which you should check out the &lt;a href=&#34;https://github.com/serdmanczyk/masters-thesis&#34;&gt;source code for&lt;/a&gt; if you would like to see an example of receiving, parsing, and sending many different API frame types in an actual application.  Hopefully this tutorial and example code enable you to get off the ground running with your application, or better understand some feature of Python, Arduino, XBee, serial communications, etc.  If you&amp;rsquo;ve encounter any trouble running the examples, or have any questions / comments / concerns please post them in the comments so others with similar problems can see too :).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Master&#39;s Thesis</title>
      <link>http://serdmanczyk.github.io/MSEEThesis/</link>
      <pubDate>Wed, 28 May 2014 00:00:00 UTC</pubDate>
      
      <guid>http://serdmanczyk.github.io/MSEEThesis/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;I’ve decided to begin blogging my various endeavors in software development and electrical engineering hackery. To kick it off, I’m writing a post describing the work I did for my Masters of Science in Electrical Engineering thesis. This post will start it off with a brief introduction/overview, then I’ll cover individual aspects of the project.&lt;/p&gt;

&lt;p&gt;You can read my &lt;a href=&#34;http://webpages.uncc.edu/~jmconrad/GradStudents/Thesis_Erdmanczyk.pdf&#34;&gt;full thesis&lt;/a&gt; via my advisor’s website, and all source code is available to view at &lt;a href=&#34;https://github.com/serdmanczyk/masters-thesis/&#34;&gt;github.com/serdmanczyk/masters-thesis/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/syspic.jpg&#34; alt=&#34;Snapshot of computer and all Sakura boards, all outfitted with XBee radios&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The title of my thesis was “Adaptive Deployment of Mobile Sensor Nodes.” Unfortunately, like many academic paper titles, that comes off a bit vague. More specifically, my thesis involved researching a method for the dynamic deployment and maintenance of of mobile robots to act as a ‘wireless tether’ of repeaters for radio communications between a deployed robot and its base station in restrictive environments.&lt;/p&gt;

&lt;p&gt;That’s quite a mouthful, but in reality it’s actually pretty simple. Let’s consider an example use scenario:&lt;/p&gt;

&lt;p&gt;Consider you’re deploying mobile robots into a tunnel, collapsed building, or some other environment where radio communications may become restricted due to interference from obstacles. There’s various reasons you may want to do this: data gathering, equipment maintenance, locating disaster survivors, etc.. You need a way to repeat your signal to the deployed robot, and simply beefing up your transmitter strength won’t work. You could try manually placing radio repeaters, but that’s not feasible in dynamic scenarios. Instead, you could deploy robots that can intelligently move themselves in positions akin to better signal strength as well as recover their ‘tether’ in the case a node is damaged or destroyed. Applications like this were the aim of my thesis.&lt;/p&gt;

&lt;p&gt;Designing a system for these situations sounds super cool, and what I completed with my thesis would make a good bottom layer for one of these example applications. Unfortunately I was just one person, was completing my thesis alongside working full-time, had limited access to materials from my universities lab due to time/distance constraints, as well as had a limited personal budget, so obviously my thesis did not involve me designing and implement a full system of actual moving robots that can rescue you from a collapsed building.&lt;/p&gt;

&lt;p&gt;What I did do, was designed a piece of such a system and physically simulate it using my laptop and a few embedded boards. Other pieces required for a full system would include the parts for path navigation, collision avoidance, robot localization, pattern recognition, etc.&lt;/p&gt;

&lt;p&gt;My resulting application broke down into three hardware pieces performing three general tasks. The hardware pieces were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A base station run via Python. In my case a laptop, but adaptable to anything that runs python (e.g. Raspberry Pi)&lt;/li&gt;
&lt;li&gt;A tether of mobile nodes programmed in C++, implemented with &lt;a href=&#34;http://sakuraboard.net/gr-sakura_en.html&#34;&gt;Renesas Sakura&lt;/a&gt; boards (provided by my advisor), but easily adaptable to an Arduino device&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/point-multipoint-rfmodules/xbee-series1-module&#34;&gt;XBee 802.15.4&lt;/a&gt; radios for handling wireless communications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The three general tasks were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The base station would dynamically deploy nodes as needed when the most recently deployed node exceeded range&lt;/li&gt;
&lt;li&gt;Deployed nodes would maintain distance between each other in order to maintain maximal signal strength&lt;/li&gt;
&lt;li&gt;In the case a node was lost, the system of nodes would maneuver and re-connect in order to heal the wireless communications tether&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I unfortunately did not get access to sufficient equipment to make the mobile nodes autonomously mobile, and instead had to simulate movement by having the Sakura boards light LEDs indicating their desired direction and then move the boards by hand. However, in my code I did provision for the output of a pulse-width-modulated signal to control a servo or DC motors.&lt;/p&gt;

&lt;p&gt;That concludes the basic, top-level overview, now let&amp;rsquo;s delve into how I handled the networking layer in my application.&lt;/p&gt;

&lt;h2 id=&#34;networking&#34;&gt;Networking&lt;/h2&gt;

&lt;!-- EMBED: http://instagram.com/p/gZgK3NFzgv/ --&gt;

&lt;iframe src=&#34;//instagram.com/p/gZgK3NFzgv/embed/&#34; width=&#34;612&#34; height=&#34;710&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowtransparency=&#34;true&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;The XBee 802.15.4 nodes are called as such because they implement the low-level &lt;a href=&#34;http://en.wikipedia.org/wiki/IEEE_802.15.4&#34;&gt;802.15.4 protocol&lt;/a&gt;. This is a protocol designed for low-powered device networking, primarily embedded applications, that gives slower speeds but with lower power requirements. The 802.15.4 protocol provides accommodations for layers one and two of the &lt;a href=&#34;http://en.wikipedia.org/wiki/OSI_model&#34;&gt;OSI model&lt;/a&gt;. On layer one they handle converting the digital output to radio waves as well as direct sequence spread spectrum (DSSS) modulation to avoid radio interference. On layer two it provides Media Access Control techniques such as carrier sense multiple access with collision avoidance (CSMA/CA) to prevent radios attempting to access the communications medium at the same time. What 802.15.4 does not provide is networking, so it was up to my application to handle OSI layer three and up.&lt;/p&gt;

&lt;p&gt;There’s various ways to configure the XBee nodes to communicate, I won’t expound on them here. In short, I chose to use the XBee API mode to handle communicating with the radios because of the flexibility, speed, and control it offered. I chose not to use Full Function Device / Reduced Function Device functionality, or even ZigBee, to handle networking for a slew of reasons I won’t waste space divulging into here. I’ll just say they were either too power hungry, had limitations too great, or just didn’t fit.&lt;/p&gt;

&lt;p&gt;With XBee API mode, all messages sent and received from the radio needed to be packed in a frame format. In particular the transmission request frame would contain the following information:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The destination node address&lt;/li&gt;
&lt;li&gt;A frame ID (used to track transmission success)&lt;/li&gt;
&lt;li&gt;Whether or not the radio should return a ‘success’ packet if transmission succeeds&lt;/li&gt;
&lt;li&gt;The message itself&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The received packet would contain the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Source address&lt;/li&gt;
&lt;li&gt;Received signal strength indicator (RSSI) measured on message detection&lt;/li&gt;
&lt;li&gt;An optional byte to denote if message is a broadcast message&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This provided all the ingredients I needed to handle networking in-app and on-the-fly. The RSSI from the received packets is particularly interesting, as it allows the application to keep record of signal strength with nearby neighbors without additional overhead. Another good reason to use API mode, that I’ll delve into in the next part.&lt;/p&gt;

&lt;p&gt;In networking, it’s common for devices in charge of routing to manage a table containing information and routes to known addresses. In the case of my application, networking is pretty simple: either a packet is going towards the base station or away from the base station. This kept routing tables down to two addresses: the neighbor to the front and the neighbor to the back. Of course, the base station would keep check on all nodes deployed, but would only communicate to the nearest node. For deployed nodes, the front and back neighbor are assigned by the base station on deployment.&lt;/p&gt;

&lt;p&gt;So, I have a way to address which nodes to talk to, and I have a way to route messages to all other nodes in the system. Done, right? Well, of course I had more problems.&lt;/p&gt;

&lt;p&gt;As is the nature of networking, errors will occur. Packets will be lost, so I needed a way to track specifically which packets and attempt to retry. Luckily the optional bits in the transmission frame allowed my app to track which messages had succeeded or not. If a message failed, that radio would pass a message back with a frame ID, and I would use the frame ID to retrieve the message from a short-term cache and retry. If it failed too many times, I abandoned and deleted it. This provided layer two feedback and error handling.&lt;/p&gt;

&lt;p&gt;Still, there was some trouble with multi-hop messages being lost, so the next step was to have nodes send an explicit acknowledge message for messages meant to traverse several nodes. If no acknowledge from the destination node within a specified time frame, I would retry the message, and abandon after too many retries as by then the message had probably aged.&lt;/p&gt;

&lt;p&gt;So, that’s a basic overview of how I built a simple, low-level, two-way networking piece in my application. This was probably the hardest part, as this was my first time working with wireless communication and doing any explicit networking without additional software or protocol libraries. I’m welcome to any feedback on what I may not have done well enough! So to review I handled networking in my application by:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Taking full control of destination and received addresses using XBee API mode&lt;/li&gt;
&lt;li&gt;Keeping a routing table in deployed nodes of the neighboring nodes to the front and back. Inwards traffic went backwards, outwards traffic went forwards.&lt;/li&gt;
&lt;li&gt;Handling errors by retry-ing packets, abandoning after too many retries.&lt;/li&gt;
&lt;li&gt;Handling lost multi-hop packets via application level acknowledgement messages: retrying after a timeout, abandoning after too many retries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This system got packet success up to a good 95+% in scenarios with good signal strength.&lt;/p&gt;

&lt;p&gt;Now that networking is covered, our next layer to cover is using this to communicate RSSI among all of the nodes and using that to evaluate communications strength amongst the system.&lt;/p&gt;

&lt;h2 id=&#34;rss-rssi-and-syncing-measurements&#34;&gt;RSS, RSSI, and Syncing Measurements&lt;/h2&gt;

&lt;p&gt;So, what is RSS? RSS is an acronym for &lt;a href=&#34;http://en.wikipedia.org/wiki/Signal_strength&#34;&gt;Received Signal Strength&lt;/a&gt; which is a metric used to represent how strong a radio signal is when a message is received on a listening device. In lower powered applications such as with embedded radios, it can commonly be measured as the log base 10 of the ratio of the received signal power to 1 milliwatt, aka &lt;a href=&#34;http://www.rapidtables.com/electric/dBm.htm&#34;&gt;Decibel-milliwatt&lt;/a&gt; (dBm).&lt;/p&gt;

&lt;p&gt;RSS was my chosen metric in my application because of its ease of availability via the XBee communication’s API mode. By monitoring the RSS of nearby nodes I could directly observe the perceived signal strength and tie it into controlling the nodes to achieve better communications strength.  This also allowed the application to automatically account for when nodes enter areas that obstruct signal strength, something that would be difficult to detect if the it attempted to control based on a distance or mapping based approach.&lt;/p&gt;

&lt;p&gt;With XBee API mode, monitoring the RSS from received messages was easy. The difficulty is, the other node’s perceived RSS may be different from our current node’s RSS due to factors such as environmental interference or other radio’s interfering signals. Acting on just our own measurement may cause our node to move out of our neighboring node’s effective range.&lt;/p&gt;

&lt;p&gt;To account for this, I had each node keep track of RSS to its neighbor nodes on each received packet. Every second, nodes would transfer their most recent record of perceived RSS to its neighboring node. Each would keep a running average of the 10 most recently received RSS measurements, both based on perceived strength and the neighbor’s reported strength. The node would act on whichever running average was weaker. The below illustration depicts this process in a friendlier visual manner.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/RSSSync.png&#34; alt=&#34;Node RSS sync process&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Simple, right? So what about the base station? How is the base station to monitor RSS of all nodes to provide system feedback when it only communicates with the nearest node? To provide this functionality, I implemented a message to be sent from the furthest node. The first message contains the the node’s perceived RSS to its neighbor, its address, as well as the RSS reported to it. The message is passed backwards down the chain, aggregating data concerning each node’s connections and addresses as it goes. When it finally arrives at the base station, it contains information about each node’s signal strength in the chain for that snapshot in time. This process is depicted in the image below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/RSSReport.png&#34; alt=&#34;RSS report to base station process&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I’ll point out a couple important potential criticisms. Using RSS does have some deficiency as it only represents measured signal strength, but DOES NOT represent the signal-to-noise ratio during message reception. Unfortunately, time and system constraints prevented me from facilitating the measurement of SNR, but it would be a critical piece of a deliverable system. Also, keeping a running average of the RSS is subject to some aggregation of errors, and a better option may be a running mean or some more complex filtering method.&lt;/p&gt;

&lt;p&gt;So that’s how I handled monitoring and syncing signal strength between nodes in my application’s system. This functionality is critical as one of the primary objectives in the system is to maintain distance between nodes in order to maximize communication’s strength. In my  into the primary logical functions of my system: deploying nodes as needed, maintaining distance between nodes, and healing the tether when nodes go down.&lt;/p&gt;

&lt;h2 id=&#34;node-deployment&#34;&gt;Node Deployment&lt;/h2&gt;

&lt;p&gt;When it came to the system’s responsibilities of deployment, distance management, and recovery I had to make a choice with each of how I would split that responsibility among the system parts. Should the logic for deployment be a distributed protocol among the nodes? What about healing and distance management, is that something nodes should defer to the base station? In the case of deployment, the choice of centralizing the logic to the base station was an easy one.&lt;/p&gt;

&lt;p&gt;The process I chose to handle deployment is quite simple.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start-up process

&lt;ul&gt;
&lt;li&gt;On the Node:

&lt;ol&gt;
&lt;li&gt;After initialization, send broadcast announcing presence on one second interval&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;On the Base Station:

&lt;ol&gt;
&lt;li&gt;After initialization, listen for broadcasts from new nodes&lt;/li&gt;
&lt;li&gt;When a broadcast is heard, add node to internal list&lt;/li&gt;
&lt;li&gt;After a specified start-up interval begin deploying nodes&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Initial deployment:

&lt;ul&gt;
&lt;li&gt;Base Station:

&lt;ol&gt;
&lt;li&gt;Send message to first node assigning rear neighbor address as base station’s address&lt;/li&gt;
&lt;li&gt;Send deployment message (node stops broadcasting)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/InitialDeployment.png&#34; alt=&#34;Initial Deployment Visualization&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Continuous deployment:

&lt;ul&gt;
&lt;li&gt;Base Station:

&lt;ol&gt;
&lt;li&gt;On an interval, check measured RSS to most recently deployed(nearest) node&lt;/li&gt;
&lt;li&gt;If RSS drops below a set threshold (determined from testing/calculations), deploy next node:&lt;/li&gt;
&lt;li&gt;Send message to recently deployed node assigning rear address as next node to be deployed&lt;/li&gt;
&lt;li&gt;Send message to newly deployed node assigning front address as recently deployed node, and rear address as base station&lt;/li&gt;
&lt;li&gt;Send ‘deploy’ message to newly deployed node&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/ContinuousDeployment.png&#34; alt=&#34;Continuous Deployment Visualization&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Of course, each assignment and deployment message is checked for an acknowledgement from the destination; if there is no acknowledgement the process bails. Further steps would be to add additional error checking on this process.&lt;/p&gt;

&lt;!-- https://www.youtube.com/watch?v=KX1XcLeSdSU --&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/KX1XcLeSdSU&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;That sums up the deployment process, which is the simplest of the three system tasks. Now let&amp;rsquo;s go over the distance maintenance algorithm.&lt;/p&gt;

&lt;h2 id=&#34;distance-maintenance&#34;&gt;Distance Maintenance&lt;/h2&gt;

&lt;p&gt;I chose to make the distance maintenance algorithm a distributed one. The phrase ‘distributed algorithm’ tends to invoke thoughts of complexity. Implementing a distributed algorithm may require additional code to handle concurrency, error correction, message passing, etc. however in the case of my system, distributed means that I could avoid that complexity as well as increase the speed of response.&lt;/p&gt;

&lt;p&gt;My final method was actually rather simple and relied on emergent behavior.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distance Maintenance Process:

&lt;ol&gt;
&lt;li&gt;Continually move forward&lt;/li&gt;
&lt;li&gt;If RSS to rear is too low, slow down&lt;/li&gt;
&lt;li&gt;If RSS to rear is exceptionally low, stop&lt;/li&gt;
&lt;li&gt;If RSS to front is too high, stop&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/DistanceMaintenance.png&#34; alt=&#34;Psuedo-code and diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Thus the steps to implement are considerably simple. By making each nodes take these actions, the result is the tether acting as sort of a ‘spring.’ If a node moves forward, it effectively ‘pushes’ the node in front of it forwards as well. Each node will ‘pull’ the node to the front back towards it if it goes to far. If you’ve ever read up on &lt;a href=&#34;http://en.wikipedia.org/wiki/Boids&#34;&gt;Boids&lt;/a&gt;, you’ll find this similar. I wasn&amp;rsquo;t directly inspired by the work on Boids, but I suppose you could say I was indirectly inspired because I had heard of similar things in a TED talk (which I cannot remember the name of).&lt;/p&gt;

&lt;p&gt;To compare, if I had decided to centrally control distance, it would require the base station to perform a computation on what it knows of signal strengths in the tether. Because of the work I described in part three, the base station does have this information, though it may be slightly outdated when the base station would get around to computing. The base station would also need to send at least one message down the chain to notify each node of its needed control output. This adds layers of latency and possible errors in the process, whereas by having each node process individually it doesn&amp;rsquo;t require any additional messages and causes immediate changes in control output.&lt;/p&gt;

&lt;p&gt;Unfortunately, as I mentioned earlier, I never was able to acquire materials to make the nodes truly mobile, so I had to simulate movement by lighting LEDs and moving the nodes with my hands. I did write code for an output to servo motors. Maybe sometime in the future I will acquire a series of Arduino’s just to see this step, because it would be really cool to watch this be performed autonomously.&lt;/p&gt;

&lt;!-- https://www.youtube.com/watch?v=kft7dlmPVRk --&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/kft7dlmPVRk&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;So that covers how I implemented a simple, distributed, emergent algorithm to allow the mobile nodes in the system of my thesis to control their distance to each other. Now let&amp;rsquo;s look at the final and most difficult piece: handling recovery when nodes area lost.&lt;/p&gt;

&lt;h2 id=&#34;healing-the-tether-when-nodes-are-lost&#34;&gt;Healing the Tether when Nodes are Lost&lt;/h2&gt;

&lt;p&gt;If a node is lost, the nodes need not just to intelligently reconnect, they most likely also need to maneuver to be back in range of a healthy node. Once again there came the choice of whether to handle this distributively or centrally, and I once again chose the former.&lt;/p&gt;

&lt;p&gt;Any node in the system is expecting to hear from its neighbor to the front or rear at least once on every one second interval, so I made each node assume it had lost contact with a neighbor if it hadn&amp;rsquo;t heard anything in a small multiple of that time frame. If the neighbor was deemed lost the scenario is as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If lost neighbor to rear:

&lt;ol&gt;
&lt;li&gt;Begin to move backwards to approach remaining tether&lt;/li&gt;
&lt;li&gt;Begin sending ‘lost broadcast’ message announcing it’s lost its rear neighbor&lt;/li&gt;
&lt;li&gt;Upon reception of acknowledgement to lost broadcast, set new neighbor as neighbor to rear&lt;/li&gt;
&lt;li&gt;Resume standard operation&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;If lost neighbor to front:

&lt;ol&gt;
&lt;li&gt;Send notification to base station (debug purposes)&lt;/li&gt;
&lt;li&gt;Continue to move forward as normal (will approach chain in front)&lt;/li&gt;
&lt;li&gt;Listen for ‘lost broadcast’&lt;/li&gt;
&lt;li&gt;Upon reception of ‘lost broadcast’ send acknowledgement, set sender as front neighbor&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://serdmanczyk.github.io/images/msthesis/LostRecovery.png&#34; alt=&#34;Lost Node Recovery Diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, with the other steps handled the way they are, handling a lost node is actually kept rather simple. The only interruption to normal movement is the node to the front of the lost node moving backwards to recover the tether, all nodes in front of that node will move backwards to follow when RSS drops (see part five). Just as distance maintenance is handled by emergent behavior as the result of a few simple steps, so is healing the tether.&lt;/p&gt;

&lt;!-- https://www.youtube.com/watch?v=btbE84ngXd8 --&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/btbE84ngXd8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;“What about the base station?” you may ask. Won’t it continue to think that the tether includes the lost node because it deployed them in a certain order? Fortunately, no. If you’ll remember from part three, the base station receives a report from the furthest node every second containing aggregated data about each connection in the chain. If at any point the order of nodes doesn&amp;rsquo;t match the base station’s record, it will update the record to match current data.&lt;/p&gt;

&lt;p&gt;That gives a general overview of how my application handles situations where a node is lost. Once again not too complicated given the other layers are designed well.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Thus concludes the &amp;lsquo;blog-ification&amp;rsquo; of the work I did on my thesis.  I spared intricate details on coding and such, because that would drag on longer than I would wish for what I wanted to get across.  I will give a post soon on the basics of using API mode with XBees using Python and Arduino that will include code from this project.  Hopefully the general overview of how I implemented a system of mobile nodes/a base station to provide an automated wireless communications tether can be helpful to others with a similar project and/or may have just been entertaining to read.&lt;/p&gt;

&lt;p&gt;In summary the stages of work I did on my thesis were:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Networking - message routing and error handling&lt;/li&gt;
&lt;li&gt;Syncing RSS (signal strength) among nodes and base station.&lt;/li&gt;
&lt;li&gt;Automatically deploying new nodes from the base station&lt;/li&gt;
&lt;li&gt;Maintaining distance between nodes for optimal commmunications strength&lt;/li&gt;
&lt;li&gt;Healing the tether when a node is lost&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A seemingly complicated task at first, made simple by splitting it up into parts and iteratively hacking away step-by-step.  Hope you enjoyed reading!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
